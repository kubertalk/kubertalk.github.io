---
title: 数据库篇笔记-1-数据库基础概念
date: 2017-04-25 10:40:55
categories: 
	- 数据库
tags: 
	- 数据库索引
	- 数据库事务
	- 数据库锁
thumbnailImage: alphabets-cubes-love-1148572.jpg
thumbnailImagePosition: left
autoThumbnailImage: true
coverImage: galaxy.jpg
coverCaption: "A beautiful galaxy"
---

复习数据库笔记之数据库基础概念
<!--more-->
<!--toc-->

#### 数据库概念集合:

##### 锁

- **共享锁**

  又称读锁（S锁），若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，但不能加X锁，直到T释放A上的S锁。

- **排它锁**

  又称写锁（X锁），若事务T对数据对象加上X锁，则只允许T**读取和修改**A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。

- **死锁**

  进程死锁，是个计算机技术名词。它是操作系统或软件运行的一种状态：在多任务系统下，当一个或多个进程等待系统资源，而资源又被进程本身或其它进程占用时，就形成了 死锁 。

  数据库中的死锁，两个或多个事务都已经封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。

  数据库中为了实现并发控制，采取了封锁技术，但是封锁技术又会带来活锁和死锁的问题，所以死锁不是数据库事务并发带来的问题，而是解决事务并发带来的问题。

##### CRUD

- 修改表结构包括：增加字段、删除字段、增加约束、删除约束、修改缺省值、修改字段数据类型、重命名字段、重命名表。所有的这些动作都是用alter table命令执行的。

##### 事务

数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性或独立性）和Durability（持久性）的英文缩写。

​	 1. **原子性**： 指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

​	2. **一致性**： 指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。

​	3. **隔离性 （或独立性）**：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

​	4. **持久性**： 指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

- **脏读**：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
  例如：
  张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。
  与此同时，
  事务B正在读取张三的工资，读取到张三的工资为8000。
  随后，
  事务A发生异常，而回滚了事务。张三的工资又回滚为5000。
  最后，
  事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。

- **不可重复读**：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
  例如：
  在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。
  与此同时，
  事务B把张三的工资改为8000，并提交了事务。
  随后，
  在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。

- **幻读**：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
  例如：
  目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。
  此时，
  事务B插入一条工资也为5000的记录。
  这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。

- **未提交读**： 一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而 且能看到其他事务没有提交的对已有记录的更新。

- **已提交读**： 一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新。

- **可重复读**： 一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他其他事务对已有记录的更新。

- **串行化**： 一个事务在执行过程中完全看不到其他事务对数据库所做的更新。（事务执行的时候不允许别的事务并发执行。事务串行化执行，事务只能一个接着一个地执行，而不能并发执行）



##### 索引

1. **普通索引**

   普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREcolumn=）或排序条件（ORDERBYcolumn）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。唯一索引

2. **唯一索引**
   普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。

   如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。

3. **主索引**

   在前面已经反复多次强调过：必须为主键字段创建一个索引，这个索引就是所谓的“主索引”。主索引与唯一索引的唯一区别是：前者在定义时使用的关键字是PRIMARY而不是UNIQUE。主键是唯一标示的。

- **b-tree索引**
  Oracle数据库中最常见的索引类型是b-tree索引，也就是B-树索引，以其同名的计算科学结构命名。CREATE 
  INDEX语句时，默认就是在创建b-tree索引。没有特别规定可用于任何情况。
- **位图索引**(bitmap index)
  位图索引特定于该列只有几个枚举值的情况，比如性别字段，标示字段比如只有0和1的情况。
- **基于函数的索引**
  比如经常对某个字段做查询的时候是带函数操作的，那么此时建一个函数索引就有价值了。
- **分区索引和全局索引**
  这2个是用于分区表的时候。前者是分区内索引，后者是全表索引
- **反向索引**（REVERSE）
  这个索引不常见，但是特定情况特别有效，比如一个varchar(5)位字段(员工编号)含值（10001,10002,10033,10005,10016..）。这种情况默认索引分布过于密集，不能利用好服务器的并行，但是反向之后10001,20001,33001,50001,61001就有了一个很好的分布，能高效的利用好并行运算。
- **HASH索引**
  HASH索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。集群键上不同值的数目必须在创建HASH集群之前就要知道。需要在创建HASH集群的时候指定这个值。使用HASH索引必须要使用HASH集群。



##### 索引优化注意事项

1. 表的主键、外键必须有索引；
2. 数据量超过300的表应该有索引；
3. 经常与其他表进行连接的表，在连接字段上应该建立索引；
4. 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
5. 索引应该建在选择性高的字段上；
6. 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
7. 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
8. 正确选择复合索引中的主列字段，一般是选择性较好的字段；
9. 复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如
10. 则可以建立复合索引；否则考虑单字段索引；
11. 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
12. 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；
13. 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；
14. 频繁进行数据操作的表，不要建立太多的索引；
15. 删除无用的索引，避免对执行计划造成负面影响；



