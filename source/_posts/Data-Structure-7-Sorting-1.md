---
title: 数据结构篇笔记-7-冒泡&插入&选择排序
date: 2017-04-29 09:40:55
categories: 
	- 数据结构
tags: 
	- 数据结构
	- 冒泡排序
	- 插入排序
	- 选择排序
thumbnailImage: action-adventure-cliff-2334533.jpg
thumbnailImagePosition: left
autoThumbnailImage: true
coverImage: galaxy.jpg
coverCaption: "A beautiful galaxy"
---
复习数据结构笔记之冒泡&插入&选择排序
<!--more-->
<!--toc-->
### 数据结构篇-7-冒泡&插入&选择排序

#### 几种经典排序算法及其时间复杂度级别
冒泡、插入、选择 O(n^2) 基于比较
快排、归并 O(nlogn) 基于比较
计数、基数、桶 O(n) 不基于比较

#### 如何分析一个排序算法？
1.学习排序算法的思路？明确原理、掌握实现以及分析性能。
2.如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。
3.执行效率：从以下3个方面来衡量
1）最好情况、最坏情况、平均情况时间复杂度
2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑
3）比较次数和交换（或移动）次数
4.内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。
5.稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。

#### 冒泡排序
1.排序原理
1）冒泡排序只会操作相邻的两个数据。
2）对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。
3）一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。
4）优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。
2.代码实现（见文末）
3.性能分析
1）执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度
最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。
最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。
平均时间复杂度：通过有序度和逆序度来分析。

**什么是有序度？**
有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n(n-1)/2，也就是15，完全有序的情况称为满有序度。

**什么是逆序度？**
逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。
排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。
冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。

对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n(n-1)/2交换。最好情况下，初始状态有序度是n(n-1)/2，就不需要进行交互。我们可以取个中间值n(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。
换句话说，平均情况下，需要n*(n-1)/4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n^2)，所以平均情况时间复杂度就是O(n^2)。
以上的分析并不严格，但很实用，这就够了。
2）空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。
3）算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。

#### 插入排序
1.算法原理
首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。
2.代码实现（见文末）
3.性能分析
1）时间复杂度：最好、最坏、平均情况
如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n^2)。
2）空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。
3）算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。

#### 选择排序
1.算法原理
选择排序算法也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，并将其放置到已排序区间的末尾。
2.代码实现（见文末）
3.性能分析
1）时间复杂度：最好、最坏、平均情况
选择排序的最好、最坏、平均情况时间复杂度都是O(n^2)。为什么？因为无论是否有序，每个循环都会完整执行，没得商量。
2）空间复杂度：
选择排序算法空间复杂度是O(1)，是一种原地排序算法。
3）算法稳定性：
选择排序算法不是一种稳定排序算法，比如[5,8,5,2,9]这个数组，使用选择排序算法第一次找到的最小元素就是2，与第一个位置的元素5交换位置，那第一个5和中间的5的顺序就变量，所以就不稳定了。正因如此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

#### 总结&思考
1.冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？
  - 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。
  - 冒泡排序移动数据有3条赋值语句，而选择排序的交换位置的只有1条赋值语句，因此在有序度相同的情况下，冒泡排序时间复杂度是选择排序的3倍，所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。

2.今天讲的这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高。
  ![Sorting Compare](http://blog.kuberfly.me/2017/04/29/Data-Structure-7-Sorting-1/sorting_compare.jpg)
3.如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？


#### 代码实现：(python)
```
Python实现：
1.冒泡排序
def bubble_sort(ls):
    moved = False
    for i in range(len(ls)):
        for j in range(len(ls)-1-i):
            if ls[j] > ls[j+1]:
                ls[j], ls[j+1] = ls[j+1], ls[j]
                moved = True
        if not moved:
            break
2.插入排序
def insertion_sort(ls):
    for i in range(1, len(ls)):
        element = ls[i]
        loc = i - 1
        while loc >= 0:
            if element < ls[loc]:
                ls[loc+1] = ls[loc]
                loc = loc - 1
            else:
                break
        ls[loc+1] = element
3.选择排序
def selection_sort(ls):
    for i in range(len(ls)):
        min_idx = i
        for j in range(i,len(ls)):
            if ls[j] < ls[min_idx]:
                min_idx = j
        ls[i], ls[min_idx] = ls[min_idx], ls[i]
```

#### 代码实现：(java)
```
/**
 * 冒泡排序
 * @param a 待排序数组
 * @param n 数组长度
 */
public static void bubbleSort(int[] a, int n) {
        if(n<=0) return ;
for (int i = 0; i < n; i++) {
//标记一次冒泡是否存在数据交换，若存在，则改为true
boolean tag = false;
for (int j = 0; j < n-1-i; j++) {
if(a[j] > a[j+1]){
int temp = a[j];
a[j] = a[j+1];
a[j+1] = temp;
tag = true;
}
}
//若本次冒泡操作未发生数据交换，则终止冒泡操作
if (tag == false) break;
}
}

/**
 * 插入排序
 * @param a 待排序数组
 * @param n 表示数组大小
 */
public static void insertSort(int[] a, int n) {
       if(n<=1) return;
       for(int i=1;i<n;i++){
            int value=a[i];
            int j=i-1;
            //找到插入位置
            for(;j>0;j--){
            if(a[j]>value){
                  a[j+1]=a[j];//移动数据
            } else {
                  break;
            }
       }
       a[j+1]=value;//插入数据
       }
}

/**
 * 选择排序
 * @param a 待排序数组
 * @param n 数组长度
 */
public static void selectSort(int[] a, int n) {
if(n<=0) return;
        for(int i=0;i<n;i++){
             int min=i;
             for(int j=i;j<n;j++){
                  if(a[j] < a[min]) min=j;
             }
             if(min != i){
                  int temp=a[i];
                  a[i]=a[min];
                  a[min]=temp;
             }
        }
}  

```



