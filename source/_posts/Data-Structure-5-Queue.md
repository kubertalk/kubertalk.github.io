---
title: 数据结构篇笔记-5-队列
date: 2017-08-25 11:07:55
categories: 
	- 数据结构
tags: 
	- 数据结构
	- 队列
thumbnailImage: mushroom.jpg
thumbnailImagePosition: left
autoThumbnailImage: true
coverImage: galaxy.jpg
coverCaption: "A beautiful galaxy"
---
复习数据结构笔记之队列
<!--more-->
<!--toc-->
###  数据结构篇-5-队列

#### 如何理解“队列”？
1、**队列是一种操作受限的线性表数据结构**。
2、队列最大的特点就是先进先出。
3、最基本的操作：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。

#### 顺序队列和链式队列
1、**用数组实现的队列叫顺序队列，用链表实现的队列叫链式队列。**
2、队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。
3、随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。
       实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，只需要在入队时，再集中触发一次数据的搬移操作。出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。
4、基于链表的实现，同样需要两个指针：head 指针和 tail 指针。分别指向链表的第一个结点和最后一个结点。入队时，tail->next= new_node, tail = tail->next；出队时，head = head->next。

#### 循环队列
1、**循环队列**，原本数组是有头有尾的，是一条直线。把首尾相连，扳成了一个环。
2、在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，需要像环一样的循环队列。
3、要想写出没有 bug 的循环队列的实现代码，最关键的是，确定好队空和队满的判定条件。
1）队列为空的判断条件仍然是 head == tail。
2）**当队满时，(tail+1)%n=head。 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。**

*PS: 这个表达式是怎么来的。在一般情况下，我们可以看出来，当队列满时，tail+1=head。但是，有个特殊情况，就是tail=n-1，而head=0时，这时候，tail+1=n，而head=0，所以用(tail+1)%n == n%n == 0。而且，tail+1最大的情况就是 n ，不会大于 n，这样，tail+1 除了最大情况，不然怎么余 n 都是 tail+1 本身，也就是 head。这样，表达式就出现了。*



#### 阻塞队列和并发队列
1、阻塞队列
1）阻塞队列就是在队列基础上增加了阻塞操作。
2）在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。
3）**基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度**。

2、并发队列
1）**线程安全的队列，叫作并发队列**。
2）最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。
3）**实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列**。这也是循环队列比链式队列应用更加广泛的原因。

#### 线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？
一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。
1、基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
2、基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。
（除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。）

#### 【思考】
一、1、像windows操作系统的消息队列，略高级一些带有优先级。还有qt中的信号与槽函数机制，使用connect链接，其中的参数就是设置为把窗口界面消息放到消息队列，然后一次取出。比如优先级消息，窗口系统关闭，优先级高，则就直接执行关闭操作。
2、sockets网络连接队列。
3、数据库连接队列。
4、一种集群操作，很多客户端像服务端请求资源，处理高并发大量请求。把这些请求放到队列中。
5、分布式应用中的消息队列，也是一种队列结构。
二、考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。  