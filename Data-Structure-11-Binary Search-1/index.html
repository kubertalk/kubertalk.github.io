<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="google-site-verification" content="0DhOwPrg8r0NkCu3BwNH0_WgQalIXNAOanq-Gs-xLaI"><meta name="google-site-verification" content="OaEXvviVUNa10fJC2M-0qnpN6izG0NxVTQfjg1MmUsE"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Fly with You"><title>数据结构篇笔记-11-二分查找(上) - Fly with You</title><meta name="author" content="Kubert"><meta name="keywords" content="hexo,javascript,"><link rel="icon" href="kuberme.cn/assets/images/elephant.jpg"><link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kubert","sameAs":["https://github.com/kubertalk","mailto:kubertqiu@hotmail.com"],"image":"elephant.jpg"},"articleBody":"复习数据结构笔记之二分查找(上)\n\n\n\n数据结构篇-11-二分查找(上)一、什么是二分查找？二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0。\n二、时间复杂度分析？1.时间复杂度​    假设数据大小是n，每次查找后数据都会缩小为原来的一半，最坏的情况下，直到查找区间被缩小为空，才停止。所以，每次查找的数据大小是：n，n/2，n/4，…，n/(2^k)，…，这是一个等比数列。当n/(2^k)=1时，k的值就是总共缩小的次数，也是查找的总次数。而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就是O(k)。通过n/(2^k)=1，可求得k=log2n，所以时间复杂度是O(logn)。\n2.认识O(logn)\n这是一种极其高效的时间复杂度，有时甚至比O(1)的算法还要高效。为什么？\n因为logn是一个非常“恐怖“的数量级，即便n非常大，对应的logn也很小。比如n等于2的32次方，也就是42亿，而logn才32。\n由此可见，O(logn)有时就是比O(1000)，O(10000)快很多。\n\n三、如何实现二分查找？1.循环实现代码实现：\n1234567891011public int binarySearch1(int[] a, int val)&#123;int start = 0;int end = a.length - 1;while(start &lt;= end)&#123;int mid = start + (end - start) / 2;if(a[mid] &gt; val) end = mid - 1;else if(a[mid] &lt; val) start = mid + 1;else return mid;&#125;return -1;&#125;\n\n注意事项：\n\n循环退出条件是：start&lt;=end，而不是start&lt;end。\nmid的取值，使用mid=start + (end - start) / 2，而不用mid=(start + end)/2，因为如果start和end比较大的话，求和可能会发生int类型的值超出最大范围。为了把性能优化到极致，可以将除以2转换成位运算，即start + ((end - start) &gt;&gt; 1)，因为相比除法运算来说，计算机处理位运算要快得多。\nstart和end的更新：start = mid - 1，end = mid + 1，若直接写成start = mid，end=mid，就可能会发生死循环。\n\n2.递归实现1234567891011public int binarySearch(int[] a, int val)&#123;return bSear(a, val, 0, a.length-1);&#125;private int bSear(int[] a, int val, int start, int end) &#123;if(start &gt; end) return -1;int mid = start + (end - start) / 2;if(a[mid] == val) return mid;else if(a[mid] &gt; val) end = mid - 1;else start = mid + 1;return bSear(a, val, start, end);&#125;\n\n四、使用条件（应用场景的局限性）\n二分查找依赖的是顺序表结构，即数组。\n二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。\n数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。\n数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。\n\n五、思考如何在1000万个整数中快速查找某个整数？\n\n1000万个整数占用存储空间为40MB，占用空间不大，所以可以全部加载到内存中进行处理;\n用一个1000万个元素的数组存储，然后使用快排进行升序排序，时间复杂度为O(nlogn);\n在有序数组中使用二分查找算法进行查找，时间复杂度为O(logn)2.如何编程实现“求一个数的平方根”？要求精确到小数点后6位？\nLeetCode二分查找相关练习：https://leetcode-cn.com/tag/binary-search/\n\n","dateCreated":"2018-10-31T09:40:55+08:00","dateModified":"2020-04-21T16:16:03+08:00","datePublished":"2018-10-31T09:40:55+08:00","description":"复习数据结构笔记之二分查找(上)","headline":"数据结构篇笔记-11-二分查找(上)","image":["mushroom.jpg","galaxy.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"/kuberme.cn/Data-Structure-11-Binary Search-1/"},"publisher":{"@type":"Organization","name":"Kubert","sameAs":["https://github.com/kubertalk","mailto:kubertqiu@hotmail.com"],"image":"elephant.jpg","logo":{"@type":"ImageObject","url":"elephant.jpg"}},"url":"/kuberme.cn/Data-Structure-11-Binary Search-1/","keywords":"数据结构, 二分查找","thumbnailUrl":"mushroom.jpg"}</script><meta name="description" content="复习数据结构笔记之二分查找(上)"><meta name="keywords" content="数据结构,二分查找"><meta property="og:type" content="blog"><meta property="og:title" content="数据结构篇笔记-11-二分查找(上)"><meta property="og:url" content="kuberme.cn/Data-Structure-11-Binary Search-1/index.html"><meta property="og:site_name" content="Fly with You"><meta property="og:description" content="复习数据结构笔记之二分查找(上)"><meta property="og:locale" content="en"><meta property="og:updated_time" content="2020-04-21T08:16:03.868Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构篇笔记-11-二分查找(上)"><meta name="twitter:description" content="复习数据结构笔记之二分查找(上)"><meta property="og:image" content="kuberme.cn/assets/images/elephant.jpg"><meta property="og:image" content="kuberme.cn/Data-Structure-11-Binary Search-1/mushroom.jpg"><meta class="swiftype" name="image" data-type="enum" content="kuberme.cn/Data-Structure-11-Binary Search-1/mushroom.jpg"><meta property="og:image" content="kuberme.cn/Data-Structure-11-Binary Search-1/galaxy.jpg"><meta class="swiftype" name="image" data-type="enum" content="kuberme.cn/Data-Structure-11-Binary Search-1/galaxy.jpg"><link rel="stylesheet" href="/assets/css/style-fniyqlsw5pf9vc6yjgxwasnk5aedpxzktlqqyflf36mnqscn70u3wtotq7ms.min.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"> <a class="header-title-link" href="/" aria-label="">Fly with You</a></div> <a class="header-right-picture" href="#about" aria-label="Open the link: /#about"><img class="header-picture" src="/assets/images/elephant.jpg" alt="Author&#39;s picture"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"> <a href="/#about" aria-label="Read more about the author"><img class="sidebar-profile-picture" src="/assets/images/elephant.jpg" alt="Author&#39;s picture"></a><h4 class="sidebar-profile-name">Kubert</h4><h5 class="sidebar-profile-bio"><p>author.bio</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" title="主页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">主页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" title="条目"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">条目</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link open-algolia-search" href="#search" title="搜索"><i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i> <span class="sidebar-button-desc">搜索</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/kubertalk" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto:kubertqiu@hotmail.com" target="_blank" rel="noopener" title="Mail"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">Mail</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/atom.xml" title="RSS"><i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i> <span class="sidebar-button-desc">RSS</span></a></li></ul></div></nav><div class="post-header-cover text-left" style="background-image:url('/Data-Structure-11-Binary Search-1/galaxy.jpg')" data-behavior="5"><div class="post-header main-content-wrap text-left"><h1 class="post-title"> 数据结构篇笔记-11-二分查找(上)</h1><div class="post-meta"> <time datetime="2018-10-31T09:40:55+08:00">Oct 31, 2018</time> <span>in</span> <a class="category-link" href="/categories/数据结构/">数据结构</a></div></div></div><div id="main" data-behavior="5" class="hasCover hasCoverMetaIn hasCoverCaption"><article class="post"> <span class="post-header-cover-caption caption">A beautiful galaxy</span><div class="post-content markdown"><div class="main-content-wrap"><p>复习数据结构笔记之二分查找(上)</p><a id="more"></a><h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构篇-11-二分查找-上"><span class="toc-text">数据结构篇-11-二分查找(上)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、什么是二分查找？"><span class="toc-text">一、什么是二分查找？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、时间复杂度分析？"><span class="toc-text">二、时间复杂度分析？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-时间复杂度"><span class="toc-text">1.时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-认识O-logn"><span class="toc-text">2.认识O(logn)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、如何实现二分查找？"><span class="toc-text">三、如何实现二分查找？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-循环实现"><span class="toc-text">1.循环实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-递归实现"><span class="toc-text">2.递归实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、使用条件（应用场景的局限性）"><span class="toc-text">四、使用条件（应用场景的局限性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、思考"><span class="toc-text">五、思考</span></a></li></ol><h3 id="数据结构篇-11-二分查找-上"><a href="#数据结构篇-11-二分查找-上" class="headerlink" title="数据结构篇-11-二分查找(上)"></a>数据结构篇-11-二分查找(上)</h3><h4 id="一、什么是二分查找？"><a href="#一、什么是二分查找？" class="headerlink" title="一、什么是二分查找？"></a>一、什么是二分查找？</h4><p>二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0。</p><h4 id="二、时间复杂度分析？"><a href="#二、时间复杂度分析？" class="headerlink" title="二、时间复杂度分析？"></a>二、时间复杂度分析？</h4><h5 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h5><p>​ 假设数据大小是n，每次查找后数据都会缩小为原来的一半，最坏的情况下，直到查找区间被缩小为空，才停止。所以，每次查找的数据大小是：n，n/2，n/4，…，n/(2^k)，…，这是一个等比数列。当n/(2^k)=1时，k的值就是总共缩小的次数，也是查找的总次数。而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就是O(k)。通过n/(2^k)=1，可求得k=log2n，所以时间复杂度是O(logn)。</p><h5 id="2-认识O-logn"><a href="#2-认识O-logn" class="headerlink" title="2.认识O(logn)"></a>2.认识O(logn)</h5><ol><li>这是一种极其高效的时间复杂度，有时甚至比O(1)的算法还要高效。为什么？</li><li>因为logn是一个非常“恐怖“的数量级，即便n非常大，对应的logn也很小。比如n等于2的32次方，也就是42亿，而logn才32。</li><li>由此可见，O(logn)有时就是比O(1000)，O(10000)快很多。</li></ol><h4 id="三、如何实现二分查找？"><a href="#三、如何实现二分查找？" class="headerlink" title="三、如何实现二分查找？"></a>三、如何实现二分查找？</h4><h5 id="1-循环实现"><a href="#1-循环实现" class="headerlink" title="1.循环实现"></a>1.循环实现</h5><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = a.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt; val) end = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt; val) start = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>循环退出条件是：start&lt;=end，而不是start&lt;end。</li><li>mid的取值，使用mid=start + (end - start) / 2，而不用mid=(start + end)/2，因为如果start和end比较大的话，求和可能会发生int类型的值超出最大范围。为了把性能优化到极致，可以将除以2转换成位运算，即start + ((end - start) &gt;&gt; 1)，因为相比除法运算来说，计算机处理位运算要快得多。</li><li>start和end的更新：start = mid - 1，end = mid + 1，若直接写成start = mid，end=mid，就可能会发生死循环。</li></ol><h5 id="2-递归实现"><a href="#2-递归实现" class="headerlink" title="2.递归实现"></a>2.递归实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int binarySearch(int[] a, int val)&#123;</span><br><span class="line">return bSear(a, val, 0, a.length-1);</span><br><span class="line">&#125;</span><br><span class="line">private int bSear(int[] a, int val, int start, int end) &#123;</span><br><span class="line">if(start &gt; end) return -1;</span><br><span class="line">int mid = start + (end - start) / 2;</span><br><span class="line">if(a[mid] == val) return mid;</span><br><span class="line">else if(a[mid] &gt; val) end = mid - 1;</span><br><span class="line">else start = mid + 1;</span><br><span class="line">return bSear(a, val, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、使用条件（应用场景的局限性）"><a href="#四、使用条件（应用场景的局限性）" class="headerlink" title="四、使用条件（应用场景的局限性）"></a>四、使用条件（应用场景的局限性）</h3><ol><li>二分查找依赖的是顺序表结构，即数组。</li><li>二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。</li><li>数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。</li><li>数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。</li></ol><h3 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h3><p>如何在1000万个整数中快速查找某个整数？</p><ol><li>1000万个整数占用存储空间为40MB，占用空间不大，所以可以全部加载到内存中进行处理;</li><li>用一个1000万个元素的数组存储，然后使用快排进行升序排序，时间复杂度为O(nlogn);</li><li>在有序数组中使用二分查找算法进行查找，时间复杂度为O(logn)<br>2.如何编程实现“求一个数的平方根”？要求精确到小数点后6位？</li><li>LeetCode二分查找相关练习：<a href="https://leetcode-cn.com/tag/binary-search/" target="_blank" rel="noopener">https://leetcode-cn.com/tag/binary-search/</a></li></ol></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"> <span class="text-color-light text-small">TAGGED IN</span><br> <a class="tag tag--primary tag--small t-link" href="/tags/二分查找/">二分查找</a> <a class="tag tag--primary tag--small t-link" href="/tags/数据结构/">数据结构</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--disabled" aria-hidden="true"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span></a></li><li class="post-action"> <a class="post-action-btn btn btn--default tooltip--top" href="/Data-Structure-10-Sorting-4/" data-tooltip="数据结构篇笔记-10-排序算法小结" aria-label="NEXT: 数据结构篇笔记-10-排序算法小结"><span class="hide-xs hide-sm text-small icon-mr">NEXT</span><i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=kuberme.cn/Data-Structure-11-Binary Search-1/" title="Share on Facebook" aria-label="Share on Facebook"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=kuberme.cn/Data-Structure-11-Binary Search-1/" title="Share on Twitter" aria-label="Share on Twitter"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=kuberme.cn/Data-Structure-11-Binary Search-1/" title="Share on Google+" aria-label="Share on Google+"><i class="fab fa-google-plus" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><footer id="footer" class="main-content-wrap"> <span class="copyrights">Copyrights &copy; 2020 Kubert. All Rights Reserved.</span><br> <span class="upyun-image">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>&nbsp&nbsp&nbsp&nbsp CDN Accelerating Supported by <a href="https://www.upyun.com/" target="_blank" rel="external nofollow"><img src="/assets/images/upyunLogo.png" height="20" width="50"></a></span></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--disabled" aria-hidden="true"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span></a></li><li class="post-action"> <a class="post-action-btn btn btn--default tooltip--top" href="/Data-Structure-10-Sorting-4/" data-tooltip="数据结构篇笔记-10-排序算法小结" aria-label="NEXT: 数据结构篇笔记-10-排序算法小结"><span class="hide-xs hide-sm text-small icon-mr">NEXT</span><i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=kuberme.cn/Data-Structure-11-Binary Search-1/" title="Share on Facebook" aria-label="Share on Facebook"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=kuberme.cn/Data-Structure-11-Binary Search-1/" title="Share on Twitter" aria-label="Share on Twitter"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=kuberme.cn/Data-Structure-11-Binary Search-1/" title="Share on Google+" aria-label="Share on Google+"><i class="fab fa-google-plus" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div><div id="share-options-bar" class="share-options-bar" data-behavior="5"><i id="btn-close-shareoptions" class="fa fa-times"></i><ul class="share-options"><li class="share-option"><a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=kuberme.cn/Data-Structure-11-Binary Search-1/" aria-label="Share on Facebook"><i class="fab fa-facebook" aria-hidden="true"></i> <span>Share on Facebook</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=kuberme.cn/Data-Structure-11-Binary Search-1/" aria-label="Share on Twitter"><i class="fab fa-twitter" aria-hidden="true"></i> <span>Share on Twitter</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="https://plus.google.com/share?url=kuberme.cn/Data-Structure-11-Binary Search-1/" aria-label="Share on Google+"><i class="fab fa-google-plus" aria-hidden="true"></i> <span>Share on Google+</span></a></li></ul></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div> <img id="about-card-picture" src="/assets/images/elephant.jpg" alt="Author&#39;s picture"><h4 id="about-card-name">Kubert</h4><div id="about-card-bio"><p>author.bio</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>author.job</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br> Chengdu,China</div></div></div><div id="cover" style="background-image:url(/assets/images/galaxy.jpg)"></div><script src="/assets/js/script-pn1j1k5loooddhnobedbnbb3axrh5qfsl8x8kmeka2su2hkn9zbqwjkkkqva.min.js"></script></body></html>