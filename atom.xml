<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fly with You</title>
  
  <subtitle>多谷黑芝麻 &amp; 蜂蜜柚子茶</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="kuberme.cn/"/>
  <updated>2020-04-21T08:16:03.868Z</updated>
  <id>kuberme.cn/</id>
  
  <author>
    <name>Kubert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构篇笔记-11-二分查找(上)</title>
    <link href="kuberme.cn/Data-Structure-11-Binary%20Search-1/"/>
    <id>kuberme.cn/Data-Structure-11-Binary Search-1/</id>
    <published>2018-10-31T01:40:55.000Z</published>
    <updated>2020-04-21T08:16:03.868Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之二分查找(上)</p><a id="more"></a><!--toc--><h3 id="数据结构篇-11-二分查找-上"><a href="#数据结构篇-11-二分查找-上" class="headerlink" title="数据结构篇-11-二分查找(上)"></a>数据结构篇-11-二分查找(上)</h3><h4 id="一、什么是二分查找？"><a href="#一、什么是二分查找？" class="headerlink" title="一、什么是二分查找？"></a>一、什么是二分查找？</h4><p>二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0。</p><h4 id="二、时间复杂度分析？"><a href="#二、时间复杂度分析？" class="headerlink" title="二、时间复杂度分析？"></a>二、时间复杂度分析？</h4><h5 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h5><p>​    假设数据大小是n，每次查找后数据都会缩小为原来的一半，最坏的情况下，直到查找区间被缩小为空，才停止。所以，每次查找的数据大小是：n，n/2，n/4，…，n/(2^k)，…，这是一个等比数列。当n/(2^k)=1时，k的值就是总共缩小的次数，也是查找的总次数。而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就是O(k)。通过n/(2^k)=1，可求得k=log2n，所以时间复杂度是O(logn)。</p><h5 id="2-认识O-logn"><a href="#2-认识O-logn" class="headerlink" title="2.认识O(logn)"></a>2.认识O(logn)</h5><ol><li>这是一种极其高效的时间复杂度，有时甚至比O(1)的算法还要高效。为什么？</li><li>因为logn是一个非常“恐怖“的数量级，即便n非常大，对应的logn也很小。比如n等于2的32次方，也就是42亿，而logn才32。</li><li>由此可见，O(logn)有时就是比O(1000)，O(10000)快很多。</li></ol><h4 id="三、如何实现二分查找？"><a href="#三、如何实现二分查找？" class="headerlink" title="三、如何实现二分查找？"></a>三、如何实现二分查找？</h4><h5 id="1-循环实现"><a href="#1-循环实现" class="headerlink" title="1.循环实现"></a>1.循环实现</h5><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = a.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt; val) end = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt; val) start = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>循环退出条件是：start&lt;=end，而不是start&lt;end。</li><li>mid的取值，使用mid=start + (end - start) / 2，而不用mid=(start + end)/2，因为如果start和end比较大的话，求和可能会发生int类型的值超出最大范围。为了把性能优化到极致，可以将除以2转换成位运算，即start + ((end - start) &gt;&gt; 1)，因为相比除法运算来说，计算机处理位运算要快得多。</li><li>start和end的更新：start = mid - 1，end = mid + 1，若直接写成start = mid，end=mid，就可能会发生死循环。</li></ol><h5 id="2-递归实现"><a href="#2-递归实现" class="headerlink" title="2.递归实现"></a>2.递归实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int binarySearch(int[] a, int val)&#123;</span><br><span class="line">return bSear(a, val, 0, a.length-1);</span><br><span class="line">&#125;</span><br><span class="line">private int bSear(int[] a, int val, int start, int end) &#123;</span><br><span class="line">if(start &gt; end) return -1;</span><br><span class="line">int mid = start + (end - start) / 2;</span><br><span class="line">if(a[mid] == val) return mid;</span><br><span class="line">else if(a[mid] &gt; val) end = mid - 1;</span><br><span class="line">else start = mid + 1;</span><br><span class="line">return bSear(a, val, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、使用条件（应用场景的局限性）"><a href="#四、使用条件（应用场景的局限性）" class="headerlink" title="四、使用条件（应用场景的局限性）"></a>四、使用条件（应用场景的局限性）</h3><ol><li>二分查找依赖的是顺序表结构，即数组。</li><li>二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。</li><li>数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。</li><li>数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。</li></ol><h3 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h3><p>如何在1000万个整数中快速查找某个整数？</p><ol><li>1000万个整数占用存储空间为40MB，占用空间不大，所以可以全部加载到内存中进行处理;</li><li>用一个1000万个元素的数组存储，然后使用快排进行升序排序，时间复杂度为O(nlogn);</li><li>在有序数组中使用二分查找算法进行查找，时间复杂度为O(logn)<br>2.如何编程实现“求一个数的平方根”？要求精确到小数点后6位？</li><li>LeetCode二分查找相关练习：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vdGFnL2JpbmFyeS1zZWFyY2gv">https://leetcode-cn.com/tag/binary-search/<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之二分查找(上)&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二分查找" scheme="kuberme.cn/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-10-排序算法小结</title>
    <link href="kuberme.cn/Data-Structure-10-Sorting-4/"/>
    <id>kuberme.cn/Data-Structure-10-Sorting-4/</id>
    <published>2018-10-24T01:40:55.000Z</published>
    <updated>2020-04-21T08:17:41.729Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之归并&amp;快速排序</p><a id="more"></a><!--toc--><h3 id="数据结构篇-10-排序算法小结"><a href="#数据结构篇-10-排序算法小结" class="headerlink" title="数据结构篇-10-排序算法小结"></a>数据结构篇-10-排序算法小结</h3><p>总结：如何实现一个通用的高性能的排序函数？<br>一、如何选择合适的排序算法？<br>1.排序算法一览表<br>         时间复杂度 是稳定排序？ 是原地排序？<br>冒泡排序 O(n^2) 是 是<br>插入排序 O(n^2) 是 是<br>选择排序 O(n^2) 否 是<br>快速排序 O(nlogn) 否 是<br>归并排序 O(nlogn) 是 否<br>桶排序 O(n) 是 否<br>计数排序 O(n+k)，k是数据范围 是 否<br>基数排序 O(dn)，d是纬度 是 否<br>2.为什选择快速排序？<br>1）线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。<br>2）为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。<br>3）同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。<br>二、如何优化快速排序？<br>导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有2种常用方法，如下：<br>1.三数取中法<br>①从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。<br>②如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。<br>2.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。<br>3.警惕快排的递归发生堆栈溢出，有2中解决方法，如下：<br>①限制递归深度，一旦递归超过了设置的阈值就停止递归。<br>②在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。<br>三、通用排序函数实现技巧<br>1.数据量不大时，可以采取用时间换空间的思路<br>2.数据量大时，优化快排分区点的选择<br>3.防止堆栈溢出，可以选择在堆上手动模拟调用栈解决<br>4.在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序<br>5.用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致<br>四、思考<br>1.Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？</p><p>\1. 对于基本类型的数组，Java 采用的是双枢轴快速排序（Dual-Pivot Quicksort），这个算法是 Java 7 引入的。在此之前，Java 采用的是普通的快速排序，双枢轴快速排序是对普通快速排序的优化，新算法的实现代码位于类 java.util.DualPivotQuicksort 中。</p><p>\2. 对于对象类型，Java 采用的算法是 TimSort，TimSort 算法也是 Java 7 引入的。在此之前，Java 采用的是归并排序。TimSort 算法实际上是对归并排序的一系列优化，TimSort 的实现代码位于类 java.util.TimSort 中。</p><p>\3. 在这些排序算法中，如果数组长度比较小，它们还会采用效率更高的插入排序。</p><p>1，如何实现一个通用的，高性能的排序函数？</p><p>（1）线性排序算法的时间复杂度比较低，适用场景比较特殊。所以通用的排序函数不能使用线性排序算法。<br>（2）小规模数据排序，可以使用时间复杂为O(n^2)的算法；对大规模数据进行排序，时间复杂度是O(nlogn)的算法更加高效。所以为了兼顾任意数据规模的排序，一般都首选时间复杂度是O(nlogn)的排序算法。<br>（3）时间复杂度是O(nlogn)的排序算法不止一个，归并排序，快速排序，堆排序。但堆排序和快速排序使用较多。<br>（4）归并排序使用的不多是因为，空间复杂度是O(n)。</p><p>2，如何优化快速排序？<br>（1）O(n^2)的时间复杂度出现的主要原因是因为我们的分区点选的不够合理<br>在最坏情况下快速排序的时间复杂度是O(n^2)。如果数据原来是有序的或者是接近有序的，每次分区都选择最后一个数据，那快速排序算法就会变得很糟糕，时间复杂度就会退化为O(n^2)。<br>（2）最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</p><p>（3）分区算法：<br>&lt;1&gt;：三数取中法：<br>从区间的首，尾，中间分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。<br>这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，会好于单纯取某个数据。在要排序的数组比较大时，需要取更多的数。</p><p>&lt;2&gt;：随机法：<br>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度看，也不大可能会出现每次分区点都选的很差的情况。</p><p>Arrays.sort<br>java8的排序<br>长度小于47：插入排序，包含普通插入排序和成对插入排序<br>长度小于286:快排，选择了两个pivote<br>长度大于286:检查数据是否有序，使用TimeSort或者快排</p><p>关于快排递归过深的处理的疑惑，以及关于 STL 里的 std::sort 是怎么实现的，可以看我这篇博客：<span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAxOC8wOS8xOC9zdGQtc29ydC1pbi1TVEwv">https://liam.page/2018/09/18/std-sort-in-STL/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之归并&amp;amp;快速排序&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="归并排序" scheme="kuberme.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="kuberme.cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-9-桶&amp;计数&amp;基数排序</title>
    <link href="kuberme.cn/Data-Structure-9-Sorting-3/"/>
    <id>kuberme.cn/Data-Structure-9-Sorting-3/</id>
    <published>2018-10-23T02:40:55.000Z</published>
    <updated>2020-04-21T11:26:44.019Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之桶&amp;计数&amp;基数排序</p><a id="more"></a><!--toc--><h3 id="数据结构篇-9-线性排序"><a href="#数据结构篇-9-线性排序" class="headerlink" title="数据结构篇-9-线性排序"></a>数据结构篇-9-线性排序</h3><h4 id="线性排序算法介绍"><a href="#线性排序算法介绍" class="headerlink" title="线性排序算法介绍"></a>线性排序算法介绍</h4><p>1.线性排序算法包括桶排序、计数排序、基数排序。<br>2.线性排序算法的时间复杂度为O(n)。<br>3.此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。<br>4.对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。</p><h4 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h4><p>1.算法原理：<br>1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序或归并排序。<br>2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br>2.使用条件<br>1）要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。<br>2）数据在各个桶之间分布是均匀的。<br>3.适用场景<br>1）桶排序比较适合用在外部排序中。<br>2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。<br>4.算法分析<br>1)时间复杂度: 最好o(n), 最坏o(nlogn), 平均o(n)，一般桶分的越细越多复杂度就会最好。<br>2)内存消耗: o(n)<br>3)稳定性: 取决于每个桶的排序方式，快排就不稳定，归并就稳定。<br>5.应用案例<br>1）需求描述：<br>有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序<br>但内存有限，仅几百MB<br>2）解决思路：<br>扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。<br>第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。<br>每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。<br>将100个小文件依次放入内存并用快排排序。<br>所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。<br>3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。</p><h4 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h4><p>1.算法原理<br>1）计数其实就是桶排序的一种特殊情况。即每个下标代表一个数据范围，其值就是这个数据的个数。<br>2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶.<br>3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。<br>2.代码实现(见文末)<br>案例分析：<br>假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。<br>使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。<br>C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。<br>对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。<br>数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？<br>从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。<br>以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。<br>执行步骤:</p><ul><li>1).找出需要排序的数组的最大值</li><li>2).声明一个新的数组c，用于计数数组使用。此时申请的数组大小为第一步得出的最大值+1</li><li>3).遍历原始数组，将所在的计数数组的对应的下标的值进行累加1</li><li>4).遍历计数数组，将数组从1开始往后累计，</li><li>5).创建跟原始数组大小空间的临时数组</li><li>6).遍历原始数组，根据原始数组值找到对应计数的数组的所对应的下标，并且减一（数组从0开始）</li><li>7).将临时数组拷贝到原始数组<br>总结：此处使用创建2次原始额外空间，所以计数数组，使用场景只能是排序的数组原始范围不大，但是数据量非常大的场景，使用场景非常有限</li></ul><p>3.使用条件<br>1）只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；<br>2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；<br>3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。<br>4.算法分析<br>1)时间复杂度: 都是o(n)<br>2)内存消耗: o(n)<br>3)稳定性: 稳定，只要整理最后结果时从后开始遍历即可。</p><h4 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h4><p>1.算法原理<br>对数据的每一位进行桶排序或计数排序，对每位排序后结果就是有序的。<br>2.案例说明（以排序10万个手机号为例来说明）<br>1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。<br>2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。<br>3）经过11次排序后，手机号码就变为有序的了。<br>4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。<br>2.使用条件<br>1）要求数据可以分割独立的“位”来比较；<br>2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；<br>3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。<br>4.算法分析<br>1）时间复杂度: 最好o(n), 最坏o(nlogn), 平均o(n)<br>2）内存消耗: o(n)<br>3）稳定性: 稳定。否则就排不成的。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.如何根据年龄给100万用户数据排序？<br>答：我们假设年龄的范围最小 1 岁，最大不超过 120 岁。我们可以遍历这 100 万用户，根据年龄将其划分到这 120个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。</p><p>2.对D，a，F，B，c，A，z这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如经过排序后为a，c，z，D，F，B，A，这个如何实现呢？如果字符串中处理大小写，还有数字，将数字放在最前面，又该如何解决呢？<br>答：用两个指针a、b：a指针从头开始往后遍历，遇到大写字母就停下，b从后往前遍历，遇到小写字母就停下，交换a、b指针对应的元素；重复如上过程，直到a、b指针相交。<br>对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换后再在非小写字母区间内分为数字和大写字母做同样处理。</p><p>附：计数排序代码实现(java版)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class CountingSort &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 计数排序</span><br><span class="line">     *</span><br><span class="line">     * @param arr 要排序的数组大小</span><br><span class="line">     * @param n 数组元素个数</span><br><span class="line">     */</span><br><span class="line">    public static void sort(int[] arr, int n) &#123;</span><br><span class="line">        if (n &lt;= 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //默认数组最大的元素为数组第一个元素</span><br><span class="line">        int max = arr[0];</span><br><span class="line">        //遍历数组的所有的元素，找到最大的元素</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            //若后面的元素大于指定的数组元素，则把元素进行交换</span><br><span class="line">            if (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //申请一个计数数组，下标从0~max。</span><br><span class="line">        int[] c = new int[max + 1];</span><br><span class="line"></span><br><span class="line">        //遍历数组，将每个元素的个数放入到计数数组中，比如分数为0的元素，在c[0]就累加1，依次类推</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            c[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //开始重新整理c[]数组，将c[]数组顺序求和，比如分数0的个数1，分数为1的个数为3。那么重新整理后，分数&lt;=0的为1，分数&lt;=1人数诶1+3=4个，因为包含了&lt;=0的个数，依次类推</span><br><span class="line">        //所以终止条件为i&lt;=max</span><br><span class="line">        for (int i = 1; i &lt;= max; i++) &#123;</span><br><span class="line">            c[i] = c[i] + c[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //这时候开始进行排序，创建一个跟要排序的数组一样大小的数据空间</span><br><span class="line">        int[] temp = new int[n];</span><br><span class="line"></span><br><span class="line">        //开始循环需要排序的数据</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //计算出需要往temp临时数组哪个索引位置存放arr[i]的值。</span><br><span class="line">            //根据原始数组的值找到计数数组的对应值的计数个数，得到c[arr[i]]的值，也就是temp数组从0开始，所以需要减一</span><br><span class="line">            int index = c[arr[i]] - 1;</span><br><span class="line">            temp[index] = arr[i];</span><br><span class="line">            //每次循环，计数数组的元素值减一，因为数组放到了temp数组中</span><br><span class="line">            c[arr[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //重新赋值</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之桶&amp;amp;计数&amp;amp;基数排序&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="桶排序" scheme="kuberme.cn/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="计数排序" scheme="kuberme.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="kuberme.cn/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-8-归并&amp;快速排序</title>
    <link href="kuberme.cn/Data-Structure-8-Sorting-2/"/>
    <id>kuberme.cn/Data-Structure-8-Sorting-2/</id>
    <published>2018-10-23T01:40:55.000Z</published>
    <updated>2020-04-21T11:26:12.479Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之归并&amp;快速排序</p><a id="more"></a><!--toc--><h3 id="数据结构篇-8-归并-amp-快速排序"><a href="#数据结构篇-8-归并-amp-快速排序" class="headerlink" title="数据结构篇-8-归并&amp;快速排序"></a>数据结构篇-8-归并&amp;快速排序</h3><h4 id="一、分治思想"><a href="#一、分治思想" class="headerlink" title="一、分治思想"></a>一、分治思想</h4><ol><li><p>分治思想：分治，顾明思意，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。</p></li><li><p>分治与递归的区别：分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。 </p></li></ol><h4 id="二、归并排序"><a href="#二、归并排序" class="headerlink" title="二、归并排序"></a>二、归并排序</h4><h5 id="1-算法原理"><a href="#1-算法原理" class="headerlink" title="1.算法原理"></a>1.算法原理</h5><p>先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下 递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) </p><p>终止条件：p &gt;= r 不用再继续分解 </p><h5 id="2-代码实现（见文末）"><a href="#2-代码实现（见文末）" class="headerlink" title="2.代码实现（见文末）"></a>2.代码实现（见文末）</h5><h5 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3.性能分析"></a>3.性能分析</h5><p>​    1）算法稳定性： 归并排序稳不稳定关键要看merge()函数，也就是两个子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们就可以像伪代码中那样，先把 A[p…q] 中的元素放入tmp数组，这样 就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一种稳定排序算法。 </p><p>​    2）时间复杂度：分析归并排序的时间复杂度就是分析递归代码的时间复杂度 </p><p>如何分析递归代码的时间复杂度？ </p><p>​    递归的适用场景是一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。若定义求解问题a的时间是T(a)，则求解问题b、c的时间分别是T(b)和T(c)，那就可以得到这样的递推公式：T(a) = T(b) + T(c) + K，其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。这里有一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，那么归并排序的时间复杂度就可以表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。 </span><br><span class="line"></span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1，其中n就是merge()函数合并两个子数组的的时间复杂度O(n)。 *</span><br><span class="line"></span><br><span class="line">T(n) = 2T(n/2) + n      </span><br><span class="line"></span><br><span class="line">= 2(2T(n/4) + n/2) + n </span><br><span class="line"></span><br><span class="line">= 4T(n/4) + 2n      </span><br><span class="line"></span><br><span class="line">= 4(2T(n/8) + n/4) + 2n = 8T(n/8) + 3*n      *</span><br><span class="line"></span><br><span class="line">= 8(2T(n/16) + n/8) + 3n = 16T(n/16) + 4n      ......      </span><br><span class="line"></span><br><span class="line">= 2^k * T(n/2^k) + k * n      ......</span><br></pre></td></tr></table></figure><p>​    当T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到k=log2n。将k带入上面的公式就得到T(n)=Cn+nlog2n。如用大O表示法，T(n)就等于O(nlogn)。所以，归并排序的是复杂度时间复杂度就是O(nlogn)。 </p><p>​    3）空间复杂度：归并排序算法不是原地排序算法，空间复杂度是O(n) 为什么？</p><p>​    因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间。为什么空间复杂度是O(n)而不是O(nlogn)呢？如果我们按照分析递归的时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)，但这种分析思路是有问题的！因为，在实际上，递归代码的空间复杂度并不是像时间复杂度那样累加，而是这样的过程，<strong>即在每次合并过程中都需要申请额外的内存空间，</strong>但是合并完成后，临时开辟的内存空间就被释放掉了，在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时空间再大也不会超过n个数据的大小，所以空间复杂度是O(n)。</p><h4 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h4><h5 id="1-算法原理-1"><a href="#1-算法原理-1" class="headerlink" title="1.算法原理"></a>1.算法原理</h5><p>​    快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。 </p><p>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r) </p><p>终止条件：p &gt;= r</p><h5 id="2-代码实现（见文末）-1"><a href="#2-代码实现（见文末）-1" class="headerlink" title="2.代码实现（见文末）"></a>2.代码实现（见文末）</h5><h5 id="3-性能分析-1"><a href="#3-性能分析-1" class="headerlink" title="3.性能分析"></a>3.性能分析</h5><p>​    1）算法稳定性： 因为分区过程中涉及交换操作，如果数组中有两个8，其中一个是pivot，经过分区处理后，后面的8就有可能放到了另一个8的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组[1,2,3,9,8,11,8]，取后面的8作为pivot，那么分区后就会将后面的8与9进行交换。 </p><p>​    2）时间复杂度：最好、最坏、平均情况 </p><p>快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。 </p><p>如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C.</span><br><span class="line"></span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1 所以，快排的时间复杂度也是O(nlogn).</span><br></pre></td></tr></table></figure><p>​    如果数组中的元素原来已经有序了，比如1，3，5，6，8，若每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的，需要进行大约n次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约n/2个元素，这种情况下，快排的时间复杂度就是O(n^2)。 </p><p>​    前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)，而且我们也有很多方法将这个概率降低。 </p><h5 id="3）空间复杂度："><a href="#3）空间复杂度：" class="headerlink" title="3）空间复杂度："></a>3）空间复杂度：</h5><p>​    快排是一种原地排序算法，空间复杂度是O(1) </p><h4 id="四、归并排序与快速排序的区别"><a href="#四、归并排序与快速排序的区别" class="headerlink" title="四、归并排序与快速排序的区别"></a>四、归并排序与快速排序的区别</h4><p>​    归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？ </p><p>​    1.归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。 </p><p>​    2.快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。 </p><h4 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h4><p>​    1.O(n)时间复杂度内求无序数组中第K大元素，比如4，2，5，12，3这样一组数据，第3大元素是4。 我们选择数组区间A[0…n-1]的最后一个元素作为pivot，对数组A[0…n-1]进行原地分区，这样数组就分成了3部分，A[0…p-1]、A[p]、A[p+1…n-1]。 </p><p>​    如果如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1，说明第K大元素出现在A[p+1…n-1]区间，我们按照上面的思路递归地在A[p+1…n-1]这个区间查找。同理，如果K&lt;p+1，那我们就在A[0…p-1]区间查找。 </p><p>​    时间复杂度分析？ 第一次分区查找，我们需要对大小为n的数组进行分区操作，需要遍历n个元素。第二次分区查找，我们需要对大小为n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数分别为n、n/2、n/4、n/8、n/16……直到区间缩小为1。如果把每次分区遍历的元素个数累加起来，就是等比数列求和，结果为2n-1。所以，上述解决问题的思路为O(n)。 </p><p>​    2.有10个访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。现在需要将这10个较小的日志文件合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述任务的机器内存只有1GB，你有什么好的解决思路能快速地将这10个日志文件合并？</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序算法, A 是数组，n 表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">// 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  // 递归终止条件</span><br><span class="line">  if p &gt;= r then return</span><br><span class="line">  // 取 p 到 r 之间的中间位置 q</span><br><span class="line">  q = (p+r) / 2</span><br><span class="line">  // 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i := p，j := q+1，k := 0 // 初始化变量 i, j, k</span><br><span class="line">  var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组</span><br><span class="line">  while i&lt;=q AND j&lt;=r do &#123;</span><br><span class="line">    if A[i] &lt;= A[j] &#123;</span><br><span class="line">      tmp[k++] = A[i++] // i++ 等于 i:=i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] = A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start := i，end := q</span><br><span class="line">  if j&lt;=r then start := j, end:=r</span><br><span class="line">  // 将剩余的数据拷贝到临时数组 tmp</span><br><span class="line">  while start &lt;= end do &#123;</span><br><span class="line">    tmp[k++] = A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  // 将 tmp 中的数组拷贝回 A[p...r]</span><br><span class="line">  for i:=0 to r-p do &#123;</span><br><span class="line">    A[p+i] = tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">注：merge()合并函数如果借助哨兵代码就会简洁很多。</span><br></pre></td></tr></table></figure><h5 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序，A 是数组，n 表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">// 快速排序递归函数，p,r 为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;= r then return</span><br><span class="line">  q = partition(A, p, r) // 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br><span class="line">//分区函数</span><br><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot := A[r]</span><br><span class="line">  i := p</span><br><span class="line">  for j := p to r-1 do &#123;</span><br><span class="line">    if A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i := i+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  return i</span><br><span class="line">&#125;</span><br><span class="line">分区函数代码说明：通过游标i把A[p...r-1]分成2部分，A[p...i-1]的元素都是小于pivot的，我们暂且叫它“已处理区间”，A[i+1...r-1]是“未处理区间”。我们每次都从未处理区间取出一个元素A[j]，与poivt相比，如果小于pivot，则将其加入到已处理区间的尾部，也就是A[i]位置。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之归并&amp;amp;快速排序&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="归并排序" scheme="kuberme.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="kuberme.cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-7-冒泡&amp;插入&amp;选择排序</title>
    <link href="kuberme.cn/Data-Structure-7-Sorting-1/"/>
    <id>kuberme.cn/Data-Structure-7-Sorting-1/</id>
    <published>2018-10-16T01:40:55.000Z</published>
    <updated>2020-04-21T11:27:52.116Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之冒泡&amp;插入&amp;选择排序</p><a id="more"></a><!--toc--><h3 id="数据结构篇-7-冒泡-amp-插入-amp-选择排序"><a href="#数据结构篇-7-冒泡-amp-插入-amp-选择排序" class="headerlink" title="数据结构篇-7-冒泡&amp;插入&amp;选择排序"></a>数据结构篇-7-冒泡&amp;插入&amp;选择排序</h3><h4 id="几种经典排序算法及其时间复杂度级别"><a href="#几种经典排序算法及其时间复杂度级别" class="headerlink" title="几种经典排序算法及其时间复杂度级别"></a>几种经典排序算法及其时间复杂度级别</h4><p>冒泡、插入、选择 O(n^2) 基于比较<br>快排、归并 O(nlogn) 基于比较<br>计数、基数、桶 O(n) 不基于比较</p><h4 id="如何分析一个排序算法？"><a href="#如何分析一个排序算法？" class="headerlink" title="如何分析一个排序算法？"></a>如何分析一个排序算法？</h4><p>1.学习排序算法的思路？明确原理、掌握实现以及分析性能。<br>2.如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。<br>3.执行效率：从以下3个方面来衡量<br>1）最好情况、最坏情况、平均情况时间复杂度<br>2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑<br>3）比较次数和交换（或移动）次数<br>4.内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。<br>5.稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>1.排序原理<br>1）冒泡排序只会操作相邻的两个数据。<br>2）对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。<br>3）一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。<br>4）优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。<br>2.代码实现（见文末）<br>3.性能分析<br>1）执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度<br>最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。<br>最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。<br>平均时间复杂度：通过有序度和逆序度来分析。</p><p><strong>什么是有序度？</strong><br>有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n(n-1)/2，也就是15，完全有序的情况称为满有序度。</p><p><strong>什么是逆序度？</strong><br>逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。<br>排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。<br>冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。</p><p>对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n(n-1)/2交换。最好情况下，初始状态有序度是n(n-1)/2，就不需要进行交互。我们可以取个中间值n(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。<br>换句话说，平均情况下，需要n*(n-1)/4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n^2)，所以平均情况时间复杂度就是O(n^2)。<br>以上的分析并不严格，但很实用，这就够了。<br>2）空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。<br>3）算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。</p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>1.算法原理<br>首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。<br>2.代码实现（见文末）<br>3.性能分析<br>1）时间复杂度：最好、最坏、平均情况<br>如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n^2)。<br>2）空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。<br>3）算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>1.算法原理<br>选择排序算法也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，并将其放置到已排序区间的末尾。<br>2.代码实现（见文末）<br>3.性能分析<br>1）时间复杂度：最好、最坏、平均情况<br>选择排序的最好、最坏、平均情况时间复杂度都是O(n^2)。为什么？因为无论是否有序，每个循环都会完整执行，没得商量。<br>2）空间复杂度：<br>选择排序算法空间复杂度是O(1)，是一种原地排序算法。<br>3）算法稳定性：<br>选择排序算法不是一种稳定排序算法，比如[5,8,5,2,9]这个数组，使用选择排序算法第一次找到的最小元素就是2，与第一个位置的元素5交换位置，那第一个5和中间的5的顺序就变量，所以就不稳定了。正因如此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p><h4 id="总结-amp-思考"><a href="#总结-amp-思考" class="headerlink" title="总结&amp;思考"></a>总结&amp;思考</h4><p>1.冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p><ul><li>冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</li><li>冒泡排序移动数据有3条赋值语句，而选择排序的交换位置的只有1条赋值语句，因此在有序度相同的情况下，冒泡排序时间复杂度是选择排序的3倍，所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。</li></ul><p>2.今天讲的这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高。<br>  <img src="http://blog.kuberfly.me/2017/04/29/Data-Structure-7-Sorting-1/sorting_compare.jpg" alt="Sorting Compare"><br>3.如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？</p><h4 id="代码实现：-python"><a href="#代码实现：-python" class="headerlink" title="代码实现：(python)"></a>代码实现：(python)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Python实现：</span><br><span class="line">1.冒泡排序</span><br><span class="line">def bubble_sort(ls):</span><br><span class="line">    moved = False</span><br><span class="line">    for i in range(len(ls)):</span><br><span class="line">        for j in range(len(ls)-1-i):</span><br><span class="line">            if ls[j] &gt; ls[j+1]:</span><br><span class="line">                ls[j], ls[j+1] = ls[j+1], ls[j]</span><br><span class="line">                moved = True</span><br><span class="line">        if not moved:</span><br><span class="line">            break</span><br><span class="line">2.插入排序</span><br><span class="line">def insertion_sort(ls):</span><br><span class="line">    for i in range(1, len(ls)):</span><br><span class="line">        element = ls[i]</span><br><span class="line">        loc = i - 1</span><br><span class="line">        while loc &gt;= 0:</span><br><span class="line">            if element &lt; ls[loc]:</span><br><span class="line">                ls[loc+1] = ls[loc]</span><br><span class="line">                loc = loc - 1</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        ls[loc+1] = element</span><br><span class="line">3.选择排序</span><br><span class="line">def selection_sort(ls):</span><br><span class="line">    for i in range(len(ls)):</span><br><span class="line">        min_idx = i</span><br><span class="line">        for j in range(i,len(ls)):</span><br><span class="line">            if ls[j] &lt; ls[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        ls[i], ls[min_idx] = ls[min_idx], ls[i]</span><br></pre></td></tr></table></figure><h4 id="代码实现：-java"><a href="#代码实现：-java" class="headerlink" title="代码实现：(java)"></a>代码实现：(java)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> * @param a 待排序数组</span><br><span class="line"> * @param n 数组长度</span><br><span class="line"> */</span><br><span class="line">public static void bubbleSort(int[] a, int n) &#123;</span><br><span class="line">        if(n&lt;=0) return ;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">//标记一次冒泡是否存在数据交换，若存在，则改为true</span><br><span class="line">boolean tag = false;</span><br><span class="line">for (int j = 0; j &lt; n-1-i; j++) &#123;</span><br><span class="line">if(a[j] &gt; a[j+1])&#123;</span><br><span class="line">int temp = a[j];</span><br><span class="line">a[j] = a[j+1];</span><br><span class="line">a[j+1] = temp;</span><br><span class="line">tag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//若本次冒泡操作未发生数据交换，则终止冒泡操作</span><br><span class="line">if (tag == false) break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> * @param a 待排序数组</span><br><span class="line"> * @param n 表示数组大小</span><br><span class="line"> */</span><br><span class="line">public static void insertSort(int[] a, int n) &#123;</span><br><span class="line">       if(n&lt;=1) return;</span><br><span class="line">       for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            int value=a[i];</span><br><span class="line">            int j=i-1;</span><br><span class="line">            //找到插入位置</span><br><span class="line">            for(;j&gt;0;j--)&#123;</span><br><span class="line">            if(a[j]&gt;value)&#123;</span><br><span class="line">                  a[j+1]=a[j];//移动数据</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                  break;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       a[j+1]=value;//插入数据</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> * @param a 待排序数组</span><br><span class="line"> * @param n 数组长度</span><br><span class="line"> */</span><br><span class="line">public static void selectSort(int[] a, int n) &#123;</span><br><span class="line">if(n&lt;=0) return;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">             int min=i;</span><br><span class="line">             for(int j=i;j&lt;n;j++)&#123;</span><br><span class="line">                  if(a[j] &lt; a[min]) min=j;</span><br><span class="line">             &#125;</span><br><span class="line">             if(min != i)&#123;</span><br><span class="line">                  int temp=a[i];</span><br><span class="line">                  a[i]=a[min];</span><br><span class="line">                  a[min]=temp;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之冒泡&amp;amp;插入&amp;amp;选择排序&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="冒泡排序" scheme="kuberme.cn/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="kuberme.cn/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="kuberme.cn/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-6-递归</title>
    <link href="kuberme.cn/Data-Structure-6-Recursion/"/>
    <id>kuberme.cn/Data-Structure-6-Recursion/</id>
    <published>2018-10-14T02:03:55.000Z</published>
    <updated>2020-04-21T11:25:12.767Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之递归</p><a id="more"></a><!--toc--><h3 id="数据结构篇-6-递归"><a href="#数据结构篇-6-递归" class="headerlink" title="数据结构篇-6-递归"></a>数据结构篇-6-递归</h3><h4 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h4><p>1.递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。<br>2.方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。<br>3.基本上，所有的递归问题都可以用递推公式来表示，比如<br>f(n) = f(n-1) + 1;<br>f(n) = f(n-1) + f(n-2);<br>f(n)=n*f(n-1);</p><h4 id="为什么使用递归？递归的优缺点？"><a href="#为什么使用递归？递归的优缺点？" class="headerlink" title="为什么使用递归？递归的优缺点？"></a>为什么使用递归？递归的优缺点？</h4><p>1.优点：代码的表达力很强，写起来简洁。<br>2.缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。</p><h4 id="什么样的问题可以用递归解决呢？"><a href="#什么样的问题可以用递归解决呢？" class="headerlink" title="什么样的问题可以用递归解决呢？"></a>什么样的问题可以用递归解决呢？</h4><p>一个问题只要同时满足以下3个条件，就可以用递归来解决：<br><strong>1.问题的解可以分解为几个子问题的解</strong>。何为子问题？就是数据规模更小的问题。<br><strong>2.问题与子问题，除了数据规模不同，求解思路完全一样</strong><br><strong>3.存在递归终止条件</strong></p><h4 id="如何实现递归？"><a href="#如何实现递归？" class="headerlink" title="如何实现递归？"></a>如何实现递归？</h4><p>1.递归代码编写<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>**编写递归代码的技巧：</p><ol><li>终止条件 </li><li>递推公式 </li><li>清理现场**</li></ol><p>2.递归代码理解<br>对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。<br>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p><h4 id="递归常见问题及解决方案"><a href="#递归常见问题及解决方案" class="headerlink" title="递归常见问题及解决方案"></a>递归常见问题及解决方案</h4><p>1.警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。<br>2.警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。</p><h4 id="如何将递归改写为非递归代码？"><a href="#如何将递归改写为非递归代码？" class="headerlink" title="如何将递归改写为非递归代码？"></a>如何将递归改写为非递归代码？</h4><p>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之递归&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="kuberme.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-5-队列</title>
    <link href="kuberme.cn/Data-Structure-5-Queue/"/>
    <id>kuberme.cn/Data-Structure-5-Queue/</id>
    <published>2018-10-13T03:07:55.000Z</published>
    <updated>2020-04-21T11:24:41.202Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之队列</p><a id="more"></a><!--toc--><h3 id="数据结构篇-5-队列"><a href="#数据结构篇-5-队列" class="headerlink" title="数据结构篇-5-队列"></a>数据结构篇-5-队列</h3><h4 id="如何理解“队列”？"><a href="#如何理解“队列”？" class="headerlink" title="如何理解“队列”？"></a>如何理解“队列”？</h4><p>1、<strong>队列是一种操作受限的线性表数据结构</strong>。<br>2、队列最大的特点就是先进先出。<br>3、最基本的操作：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p><h4 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h4><p>1、<strong>用数组实现的队列叫顺序队列，用链表实现的队列叫链式队列。</strong><br>2、队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。<br>3、随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。<br>       实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，只需要在入队时，再集中触发一次数据的搬移操作。出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。<br>4、基于链表的实现，同样需要两个指针：head 指针和 tail 指针。分别指向链表的第一个结点和最后一个结点。入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>1、<strong>循环队列</strong>，原本数组是有头有尾的，是一条直线。把首尾相连，扳成了一个环。<br>2、在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，需要像环一样的循环队列。<br>3、要想写出没有 bug 的循环队列的实现代码，最关键的是，确定好队空和队满的判定条件。<br>1）队列为空的判断条件仍然是 head == tail。<br>2）<strong>当队满时，(tail+1)%n=head。 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</strong></p><p><em>PS: 这个表达式是怎么来的。在一般情况下，我们可以看出来，当队列满时，tail+1=head。但是，有个特殊情况，就是tail=n-1，而head=0时，这时候，tail+1=n，而head=0，所以用(tail+1)%n == n%n == 0。而且，tail+1最大的情况就是 n ，不会大于 n，这样，tail+1 除了最大情况，不然怎么余 n 都是 tail+1 本身，也就是 head。这样，表达式就出现了。</em></p><h4 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h4><p>1、阻塞队列<br>1）阻塞队列就是在队列基础上增加了阻塞操作。<br>2）在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br>3）<strong>基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度</strong>。</p><p>2、并发队列<br>1）<strong>线程安全的队列，叫作并发队列</strong>。<br>2）最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。<br>3）<strong>实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列</strong>。这也是循环队列比链式队列应用更加广泛的原因。</p><h4 id="线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？"><a href="#线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？" class="headerlink" title="线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？"></a>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</h4><p>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<br>1、基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。<br>2、基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。<br>（除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。）</p><h4 id="【思考】"><a href="#【思考】" class="headerlink" title="【思考】"></a>【思考】</h4><p>一、1、像windows操作系统的消息队列，略高级一些带有优先级。还有qt中的信号与槽函数机制，使用connect链接，其中的参数就是设置为把窗口界面消息放到消息队列，然后一次取出。比如优先级消息，窗口系统关闭，优先级高，则就直接执行关闭操作。<br>2、sockets网络连接队列。<br>3、数据库连接队列。<br>4、一种集群操作，很多客户端像服务端请求资源，处理高并发大量请求。把这些请求放到队列中。<br>5、分布式应用中的消息队列，也是一种队列结构。<br>二、考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之队列&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="kuberme.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-4-栈</title>
    <link href="kuberme.cn/Data-Structure-4-Stack/"/>
    <id>kuberme.cn/Data-Structure-4-Stack/</id>
    <published>2018-10-08T09:07:55.000Z</published>
    <updated>2020-04-21T11:23:58.222Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之栈</p><a id="more"></a><!--toc--><h3 id="数据结构之栈"><a href="#数据结构之栈" class="headerlink" title="数据结构之栈"></a>数据结构之栈</h3><h4 id="一、什么是栈？"><a href="#一、什么是栈？" class="headerlink" title="一、什么是栈？"></a>一、什么是栈？</h4><p>1.后进者先出，先进者后出，这就是典型的“栈”结构。<br>2.从栈的操作特性来看，<strong>是一种“操作受限”的线性表</strong>，只允许在端插入和删除数据。</p><h4 id="二、为什么需要栈？"><a href="#二、为什么需要栈？" class="headerlink" title="二、为什么需要栈？"></a>二、为什么需要栈？</h4><p>1.栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。<br>2.但，任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。<br>3.所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。</p><h4 id="三、如何实现栈？"><a href="#三、如何实现栈？" class="headerlink" title="三、如何实现栈？"></a>三、如何实现栈？</h4><p>1.栈的API<br>public class Stack<item> {<br>//压栈<br>public void push(Item item){}<br>//弹栈<br>public Item pop(){}<br>//是否为空<br>public boolean isEmpty(){}<br>//栈中数据的数量<br>public int size(){}<br>//返回栈中最近添加的元素而不删除它<br>public Item peek(){}<br>}<br>2.数组实现（自动扩容）<br>时间复杂度分析：根据均摊复杂度的定义，可以得数组实现（自动扩容）符合大多数情况是O(1)级别复杂度，个别情况是O(n)级别复杂度，比如自动扩容时，会进行完整数据的拷贝。<br>空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。<br>实现代码：（略）</item></p><p>3.链表实现<br>时间复杂度分析：压栈和弹栈的时间复杂度均为O(1)级别，因为只需更改单个节点的索引即可。<br>空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。<br>实现代码：（略）</p><h4 id="四、栈的应用"><a href="#四、栈的应用" class="headerlink" title="四、栈的应用"></a>四、栈的应用</h4><p>1.栈在函数调用中的应用<br><strong>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。</strong>每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br>2.栈在表达式求值中的应用（比如：34+13*9+44-12/3）<br>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。<br>3.栈在括号匹配中的应用（比如：{}{<a href>()</a>}）<br>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。<br>4.如何实现浏览器的前进后退功能？<br>我们使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了。</p><h4 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h4><p>​    我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？  </p><p>​    其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p><p>​    从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之栈&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="kuberme.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-3-链表</title>
    <link href="kuberme.cn/Data-Structure-3-Linked-List/"/>
    <id>kuberme.cn/Data-Structure-3-Linked-List/</id>
    <published>2018-10-05T10:21:55.000Z</published>
    <updated>2020-04-21T11:21:43.657Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之链表二</p><a id="more"></a><!--toc--><h3 id="链表篇-2"><a href="#链表篇-2" class="headerlink" title="链表篇-2"></a>链表篇-2</h3><h4 id="总结：如何优雅的写出链表代码？6大学习技巧"><a href="#总结：如何优雅的写出链表代码？6大学习技巧" class="headerlink" title="总结：如何优雅的写出链表代码？6大学习技巧"></a>总结：如何优雅的写出链表代码？6大学习技巧</h4><h5 id="一、理解指针或引用的含义"><a href="#一、理解指针或引用的含义" class="headerlink" title="一、理解指针或引用的含义"></a>一、理解指针或引用的含义</h5><p>1.含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。<br>2.示例：<br>p—&gt;next = q; 表示p节点的后继指针存储了q节点的内存地址。<br>p—&gt;next = p—&gt;next—&gt;next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。</p><h5 id="二、警惕指针丢失和内存泄漏（单链表）"><a href="#二、警惕指针丢失和内存泄漏（单链表）" class="headerlink" title="二、警惕指针丢失和内存泄漏（单链表）"></a>二、<strong>警惕指针丢失和内存泄漏</strong>（单链表）</h5><p>1.插入节点<br>在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：p—&gt;next = x;x—&gt;next = p—&gt;next; 显然这会导致x节点的后继指针指向自身。<br>正确的写法是<!--more-->2句代码交换顺序，即：x–&gt;next = p—&gt;next; p—&gt;next = x;<br>2.删除节点<br>在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：p—&gt;next = p—&gt;next—&gt;next;</p><h5 id="三、利用“哨兵”简化实现难度"><a href="#三、利用“哨兵”简化实现难度" class="headerlink" title="三、利用“哨兵”简化实现难度"></a>三、利用“哨兵”简化实现难度</h5><p>1.什么是“哨兵”？<br>链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。<br>2.未引入“哨兵”的情况<br>如果在p节点后插入一个节点，只需2行代码即可搞定：<br>new_node—&gt;next = p—&gt;next;<br>p—&gt;next = new_node;<br>但，若向空链表中插入一个节点，则代码如下：<br>if(head == null){<br>head = new_node;<br>}<br>如果要删除节点p的后继节点，只需1行代码即可搞定：<br>p—&gt;next = p—&gt;next—&gt;next;<br>但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：<br>if(head—&gt;next == null){<br>head = null;<br>}<br>从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。<br>3.引入“哨兵”的情况<br>“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。<br>4.“哨兵”还有哪些应用场景？<br>这个知识有限，暂时想不出来呀！但总结起来，哨兵最大的作用就是简化边界条件的处理。</p><h5 id="四、重点留意边界条件处理"><a href="#四、重点留意边界条件处理" class="headerlink" title="四、重点留意边界条件处理"></a>四、重点留意边界条件处理</h5><p>经常用来检查链表是否正确的边界4个边界条件：<br>1.如果链表为空时，代码是否能正常工作？<br>2.如果链表只包含一个节点时，代码是否能正常工作？<br>3.如果链表只包含两个节点时，代码是否能正常工作？<br>4.代码逻辑在处理头尾节点时是否能正常工作？</p><h5 id="五、举例画图，辅助思考"><a href="#五、举例画图，辅助思考" class="headerlink" title="五、举例画图，辅助思考"></a>五、举例画图，辅助思考</h5><p>核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。</p><h5 id="六、多写多练，没有捷径"><a href="#六、多写多练，没有捷径" class="headerlink" title="六、多写多练，没有捷径"></a>六、多写多练，没有捷径</h5><p>5个常见的链表操作：<br>1.单链表反转<br>2.链表中环的检测<br>3.两个有序链表合并<br>4.删除链表倒数第n个节点<br>5.求链表的中间节点  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之链表二&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="kuberme.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构篇笔记-2-链表</title>
    <link href="kuberme.cn/Data-Structure-2-Linked-List/"/>
    <id>kuberme.cn/Data-Structure-2-Linked-List/</id>
    <published>2018-10-03T09:21:55.000Z</published>
    <updated>2020-04-21T11:20:42.108Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据结构笔记之链表一</p><a id="more"></a><!--toc--><h3 id="链表篇-1"><a href="#链表篇-1" class="headerlink" title="链表篇-1"></a>链表篇-1</h3><h4 id="一、什么是链表？"><a href="#一、什么是链表？" class="headerlink" title="一、什么是链表？"></a>一、什么是链表？</h4><p>1.<strong>和数组一样，链表也是一种线性表</strong>。<br>2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。<br>3.链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。</p><h4 id="二、为什么使用链表？即链表的特点"><a href="#二、为什么使用链表？即链表的特点" class="headerlink" title="二、为什么使用链表？即链表的特点"></a>二、为什么使用链表？即链表的特点</h4><p>1.<strong>插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）</strong>。<br>2.<strong>和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针</strong>。</p><h4 id="三、常用链表：单链表、循环链表和双向链表"><a href="#三、常用链表：单链表、循环链表和双向链表" class="headerlink" title="三、常用链表：单链表、循环链表和双向链表"></a>三、常用链表：单链表、循环链表和双向链表</h4><p>1.单链表<br>1）每个节点只包含一个指针，即后继指针。<br>2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。<br>3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。<br>2.循环链表<br>1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。<br>2）适用于存储有循环特点的数据，比如约瑟夫问题。<br>3.双向链表<br>1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。<br>2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。<br>3）性能特点：<br>和单链表相比，存储相同的数据，需要消耗更多的存储空间。<br>插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>4.双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。</p><h4 id="四、选择数组还是链表？"><a href="#四、选择数组还是链表？" class="headerlink" title="四、选择数组还是链表？"></a>四、选择数组还是链表？</h4><p>1.插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。<br>2.数组缺点<br>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。<br>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。<br>3.链表缺点<br>1）内存空间消耗更大，因为需要额外的空间存储指针信息。<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。<br>4.如何选择？<br>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。<br>如果代码对内存的使用非常苛刻，那数组就更适合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据结构笔记之链表一&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="kuberme.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Gcc Link Sequence Issue</title>
    <link href="kuberme.cn/Gcc-Link-Sequence-Issue/"/>
    <id>kuberme.cn/Gcc-Link-Sequence-Issue/</id>
    <published>2017-05-21T02:50:11.000Z</published>
    <updated>2020-04-15T03:23:32.824Z</updated>
    
    <content type="html"><![CDATA[<p>When you use a GCC compiler or a makefile to build your project, do you know the details behind this compiling ? Let me tell you what i see and what i know.</p><a id="more"></a><!--toc--><h3 id="GCC-Link-Sequence-Issue"><a href="#GCC-Link-Sequence-Issue" class="headerlink" title="GCC Link Sequence Issue"></a>GCC Link Sequence Issue</h3><h4 id="GCC-Link-Background"><a href="#GCC-Link-Background" class="headerlink" title="GCC Link Background"></a>GCC Link Background</h4><p>GCC linker will link some object files  to only one object file.  During this time, it must replace all symbols(parameters/functions) to memory address(parameters address/functions address), for referring all sections in your object.</p><p>The most standard functions are located in “libc.a”(a means achieve), or located in shared dynamic lib “libc.so”(so means share object). these libs always located in <code>/lib/</code> or <code>/usr/lib/</code> or other folders of gcc finding setting.</p><h4 id="Simple-Case"><a href="#Simple-Case" class="headerlink" title="Simple Case"></a>Simple Case</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Use <code>gcc test.c -o test</code> to make a quick compile, for making *.c to *.exe or *.bin.</p><h4 id="four-entire-steps-in-Gcc-Compile"><a href="#four-entire-steps-in-Gcc-Compile" class="headerlink" title="four entire steps in Gcc Compile"></a>four entire steps in Gcc Compile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -E sqltest.c -o sqltest.i//firstly, make *.c preprocessing to *.i</span><br><span class="line">gcc -S sqltest.i -o sqltest.s//secondly, make *.i compiling to *.s   </span><br><span class="line">gcc -c sqltest.s -o sqltest.o//thirdly, make *.s assemblying to *.o  </span><br><span class="line">gcc sqltest.o &apos;mysql_configs --libs&apos; -o sqltest </span><br><span class="line">//finally, make *.o and *.so/*.lib/*.dll linking to *.bin</span><br><span class="line">//which &apos;mysql_configs --libs&apos; equal to &quot;-L/usr/lib/x86_64-linux-gnu -lmysqlclient -lpthread -lm -lrt -ldl&quot;</span><br></pre></td></tr></table></figure><h4 id="Sequence-issue-in-linking"><a href="#Sequence-issue-in-linking" class="headerlink" title="Sequence issue in linking"></a>Sequence issue in linking</h4><p>if you use <code>gcc &#39;mysql_configs --libs&#39;sqltest.o -o sqltest</code> to make a link, you will get errors which said “undefined reference to xxx”. but why ?</p><p>because the finding sequence about symbols and libs of linking of GCC, is from Left to Right, according to <code>-L</code> sequence. So the Mysql API in sqltest.o can not find its references if you put the mysql libs to the left place of the sqltest.o. </p><p>Solutions:</p><p>Put the lowest layer libs to the end of the linking command, like <code>gcc obj($?) -l (top logic libs) -l (middle packeted libs) -l (system libs) -o $@</code>.</p><p>Or use repeat option to your linking command, make the “ld” keep finding refer libs in your command.</p><h4 id="Other-Usage-on-library-connection"><a href="#Other-Usage-on-library-connection" class="headerlink" title="Other Usage on library connection"></a>Other Usage on library connection</h4><p>use <code>readelf -d sqltest</code> or <code>ldd sqltest</code> to see the reference connection of a <em>.bin/</em>.so/.lib.</p><p><img src="http://blog.kuberfly.me/2017/05/21/Gcc-Link-Sequence-Issue/readelf.png" alt="readelf"></p><p>Hope you have a strong makefile and happy compiling on your code.</p><p>End.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;When you use a GCC compiler or a makefile to build your project, do you know the details behind this compiling ? Let me tell you what i see and what i know.&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="kuberme.cn/categories/C/"/>
    
      <category term="Compiler" scheme="kuberme.cn/categories/C/Compiler/"/>
    
    
      <category term="GCC" scheme="kuberme.cn/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>201705 交大黑客松（Hacker Marathon)纪要</title>
    <link href="kuberme.cn/Hacker%20Marathon%20Note%20of%202017/"/>
    <id>kuberme.cn/Hacker Marathon Note of 2017/</id>
    <published>2017-05-20T01:40:55.000Z</published>
    <updated>2020-04-26T02:15:18.498Z</updated>
    
    <content type="html"><![CDATA[<p>201705 交大黑客松（Hacker Marathon)纪要</p><a id="more"></a><!--toc--><h3 id="201705-交大黑客松（Hacker-Marathon-纪要"><a href="#201705-交大黑客松（Hacker-Marathon-纪要" class="headerlink" title="201705 交大黑客松（Hacker Marathon)纪要"></a>201705 交大黑客松（Hacker Marathon)纪要</h3><h4 id="例子1–NVIDIA小车"><a href="#例子1–NVIDIA小车" class="headerlink" title="例子1–NVIDIA小车"></a>例子1–NVIDIA小车</h4><p><strong>详情描述</strong></p><p>本项目拼装了一台能够智能识别图像的小车，该小车利用摄像头捕捉物体并分类，如猫、瓶子、人等等，进而根据分类结果执行相关动作。</p><p>1.控制：在ROS环境下，利用twist结构控制小车执行相关动作，并发布topic，然后在ARDUINO中订阅该主题。</p><p>2.视觉识别：</p><p><strong>解决的问题</strong></p><p>1.小组成员在36个小时内，完成小车驱动软件的编制，并实现远程控制。</p><p>2.小车能够根据不同的图片做出不同动作，遇到障碍时会停止动作，并且操控者可以在任何时候终止小车运动。</p><p>3.具体动作有：前进、后退、原地旋转等组合动作。</p><p><strong>项目使用指南</strong></p><p>用于控制行进动作的图片可以打印在A4纸上，由操控者手举着图片让小车识别后分别执行不同的行进动作。</p><p><strong>未来发展规划</strong></p><p>1.机场加油车或拖车：</p><p>利用视觉识别功能捕捉飞机，捕捉到之后靠近目标并执行相关任务。</p><p>2.道路清扫车：</p><p>若识别到瓶子等垃圾，自动清扫；若识别到汽车或行人时，停止前进。</p><h4 id="例子2–图片识别"><a href="#例子2–图片识别" class="headerlink" title="例子2–图片识别"></a>例子2–图片识别</h4><p><strong>SDK使用情况说明</strong></p><p>我们利用了IBM Waston服务来做图片识别，之后将其转换为对应的表情包（目前是Emoji）。</p><p>服务部署在青云上，依赖于其提供的QingStor来存储上传的图片，并使用负载均衡/VPC等服务来提供高可靠的服务。</p><p>![青云API](/Users/kuber/Documents/ 青灯黄卷2/面试书籍/青云API.tiff)</p><h4 id="例子三–NVIDIA小车"><a href="#例子三–NVIDIA小车" class="headerlink" title="例子三–NVIDIA小车"></a>例子三–NVIDIA小车</h4><p>在本次比赛中，我们将深度学习中的目标识别问题与智能小车的运动控制问题相结合，顺利完成了整个比赛项目。整个项目可以分解为如下几个部分：首先，利用图像处理工具Opencv对小车摄像头接受到的图像信息进行处理，将接收图像的RGB通道信息进行处理。之后，利用深度学习领域的SSD算法进行目标识别方面的处理，利用分类识别效果很好的深度网络模型对接受到的图片信息进行识别，进而输出图像的类别信息。最后，针对接收图像的不同类别，控制智能小车做出前行、后退、原地360度左转/右转等不同动作、除此之外，还加入了利用超声波进行障碍物躲避、小车的即时停止等功能。充分利用了相关企业提供的硬件、软件资源。</p><p>![小车套件](/Users/kuber/Documents/ 青灯黄卷2/面试书籍/小车套件.tiff)</p><h4 id="例子四–NVIDIA小车"><a href="#例子四–NVIDIA小车" class="headerlink" title="例子四–NVIDIA小车"></a>例子四–NVIDIA小车</h4><p><strong>项目使用指南</strong></p><p>使用远程桌面连接小车的TK板，输入启动指令后，小车在接收到可识别的图片信号才会启动，并在遇到障碍物（距离障碍物一定距离）时停止移动。</p><p>小车的移动规律为：</p><p>识别出猫，向左转。</p><p>识别出人，向右转。</p><p>识别出车，向前进。</p><p>识别出椅子，向后退。</p><p>识别出飞机，向左转并直行。</p><p>识别出房屋，向右转并直行。</p><p><strong>核心技术说明</strong></p><p>小车本身搭载了摄像头，TK板内连接图像处理系统，通过caffeine module识别出图像内的物体，根据分析出的问题做出相应的举动。</p><p>小车内的TK板用ROS连接ardurino板，ardurino上烧录的程序根据ROS发送的信息进行相应的操作。</p><p><strong>未来发展规划</strong></p><p>搭载人脸情绪或手势识别的小型机器人。可以根据情绪信息分析进行相应操作。比如在人情绪低落时会拥抱的机器人。</p><h4 id="例子五–NVIDIA小车"><a href="#例子五–NVIDIA小车" class="headerlink" title="例子五–NVIDIA小车"></a>例子五–NVIDIA小车</h4><p><strong>详情描述</strong></p><p>本作品主要由视频采集模块、信号处理模块和控制系统组成。上位机部分由具有超强计算能力的Jetson TX1嵌入式开发板和USB相机组成，相机采集的实时数据交由TX1处理，结合Caffe深度学习框架，可以实时的识别视频中的各类物体。与此同时，向下位机发送控制指令，驱动小车做出相应的动作。并且可以通过远程控制，实现对小车的即时控制。作品流程如下图所示。</p><p>![小车项目架构](/Users/kuber/Documents/ 青灯黄卷2/面试书籍/小车项目架构.tiff)</p><p><strong>创意来源</strong></p><p>现今深度学习如此火热，对于各个领域，与其结合必将有更新更广的发展空间。而酷炫的自动驾驶技术也让我们心驰神往，路上行驶的车辆，如何有效地避让行人和车辆，如何在路口减速停车，如何有效地做路径规划等，让我们存有疑惑也充满激情。而且此次NVIDIA提供了基于嵌入式平台的智能车相关硬件和软件，队友一拍即合准备尝试NVIDIA的项目。对于智能车系统的开发，将结合NVIDIA的Jetson TX1平台和深度学习实现类似真实路况的前进，后退，停止等。</p><p><strong>解决的问题</strong></p><ol><li>对于基于视觉的自动驾驶技术，与真实的复杂路况相比，我们尝试先从相应的目标识别展开。当车辆在路上行驶时，必将对周围的路况和物体做识别判断，从而控制车辆的行进状态。所以如何有效地识别观察的物体是必不可少的环节。</li></ol><ol start="2"><li>对于前者，有效识别物体是非常重要的，而识别后对控制系统的改变也是重中之重，平稳的行驶，稳定的转弯以及及时的刹车等都是需要好好研究解决的问题。</li></ol><ol start="3"><li>对于远程控制，需要考虑传输速率的实时性问题。</li></ol><p>由英伟达公司的嵌入式GPU Jetson TX1作为主控芯片的智能小车。该设备使用开放的Linux + ROS系统，可以通过摄像头实时识别19类物体，并能根据摄像头看到六类物体做出六个不同的规定行进动作。</p><p><strong>核心技术说明</strong></p><ol><li>Caffe框架及训练的模型。</li></ol><ol start="2"><li>Arduino控制程序</li></ol><p><strong>SDK使用情况说明</strong></p><ol><li>NVIDIA  英伟达嵌入式开发平台</li></ol><ol start="2"><li>Arduino</li></ol><ol start="3"><li>Opencv</li></ol><ol start="4"><li>Caffe</li></ol><ol start="5"><li>ROS</li></ol><p><strong>未来发展规划</strong></p><ol><li>基于嵌入式平台自动驾驶技术</li></ol><p>Jetson平台具有能耗低，体积小，计算能力强等优点，能够较好地应对自动驾驶要遇到的问题。其强有力的计算能力，能够实时处理接收的数据，较多的接口，具有很强的可扩展性。</p><ol start="2"><li>车载人脸识别防盗技术</li></ol><p>现在汽车数量迅速增加，人们也有较强的防盗意识，但是现有的防盗技术，还是有很多缺点，例如钥匙被盗或者被复制的情况。而基于人脸识别的技术，能够有效的起到防盗作用，对于恶意的盗窃或者无关人员的随意借车能够有效避免。</p><ol start="3"><li>车辆（地面移动平台）智能跟随系统</li></ol><p>无人机的智能跟随系统已经很火热，而对于车辆（地面移动平台）的智能跟随系统，却少有人做。随着智能硬件（NVIDIA嵌入式开发板）计算能力的提升，对于处理地面复杂场景将有更好的解决方法和更好的愿景。</p><p>![小车套件2](/Users/kuber/Documents/ 青灯黄卷2/面试书籍/小车套件2.tiff)</p><p>![小车项目架构2](/Users/kuber/Documents/ 青灯黄卷2/面试书籍/小车项目架构2.tiff)</p><h4 id="例子六NVIDIA小车"><a href="#例子六NVIDIA小车" class="headerlink" title="例子六NVIDIA小车"></a>例子六NVIDIA小车</h4><p><strong>详情描述</strong></p><p>此款小车结合多种技术，比如SenseTime的计算机视觉识别技术，以及NVIDIA的Jetson Platform TK1作为主控芯片，使用开放的Ubuntu+ROS系统，耦合度低，扩展性强，可以搭载各类传感器，对于输入的信号进行识别。用Caffe的深度学习框架进行训练，可以识别各类物体，并做出相应的动作。此外，我们使用远程桌面控制，使得小车能够自由移动。</p><p>此款小车的创新意义在于NVIDIA GPU Jetson TX1提供了在传统机器人系统中使用的CPU无法提供的人工智能计算能力，使机器人有了一颗“智能”的大脑。</p><p><strong>创意来源</strong></p><p>无人驾驶，人机交互为当今的热点技术。在无人驾驶的热潮中，如何有效识别路况，判别障碍物为一重要的课题。比如：在无人驾驶汽车在遇到障碍物时，会根据障碍种类做出不同运动反应。如果视频输入端检测到飞鸟可以直行通过，而判断行人走路则立即停止。如何实现这类功能？我们通过把课题做在小车上，通过摄像头读取并判定前方物体信息，从而做出不同的反馈动作，验证想法的可行性。本小车作为无人驾驶技术的验证雏形，具有灵活，便捷和开放的特点。</p><p><strong>解决的问题</strong></p><p>无人驾驶概念逐步融入生活。对于无人驾驶技术，如需验证视觉算法的可行性，则需要耗费很大的空间，时间和精力：比如，汽车的安装，场地的限制和计算机视觉算法的调试。而我们的智能小车平台，则可以作为一个集成而浓缩的模型，为无人驾驶技术的验证与发展如虎添翼。</p><p>此外，智能机器人在进行人机交互的过程中，图像识别，计算机视觉为重要的一个组成部分。计算机视觉可以看作是研究如何使人工系统从图像或多维数据中“感知”的科学。计算机视觉包含如下一些分支：画面重建，事件监测，目标跟踪，目标识别，机器学习，索引建立，图像恢复等。针对“感知”，机器人可以做出不同反应，如语音反馈，动作等。从而使得人工智能上一个台阶。</p><p>本机器人是一个基于计算机视觉的人机交互平台的雏形，我们的数据集可扩大到更多不同的物品，乃至声音，自然语言等。机器人能做出的反应指令可扩大到更复杂认知，机器模型结构也可以更为复杂精密。我们的项目验证了这样一个平台的可能性，这就是我们课题所解决的问题。</p><p><strong>功能设计说明</strong></p><p>小车集多种功能于一体，摄像头模块可读取图像数据，基于OpenCV的图像识别物体目标进行识别判定；ROS平台所搭载的Arduino运动控制模块，可根据目标控制小车的运动；TX1的主板保证了基于Caffe框架的Deep Learning和的人工智能的运行；两个声纳模块的协同运作，使得小车可敏捷避障。</p><p><strong>核心技术说明</strong></p><p>SenseTime 目标-人体检测技术</p><p>NVIDIA Jetson Platform TK1 主控芯片</p><p>Caffe Setup 提供深度学习框架，接收交还的RGB数据</p><p>ROS及Arduino的集成   小车运动反应控制</p><p>Deep-CNN目标检测算法   </p><p>ROS及Arduino的集成</p><p>NVIDIA Jetson Platform TK1</p><p>Caffe Setup</p><p>Deep-CNN目标检测算法</p><p>SenseTime 目标-人体检测技术</p><p><strong>SDK**</strong>使用情况说明**</p><p>SDK</p><p>NVIDIA</p><p>Sensetime</p><p>Arduino</p><p>Caffe</p><p>Ros</p><p><strong>未来发展规划</strong></p><p>智能机器人在进行人机交互的过程中，图像识别，计算机视觉为重要的一个组成部分。计算机视觉可以看作是研究如何使人工系统从图像或多维数据中“感知”的科学。计算机视觉包含如下一些分支：画面重建，事件监测，目标跟踪，目标识别，机器学习，索引建立，图像恢复等。针对“感知”，机器人可以做出不同反应，如语音反馈，动作等。从而使得人工智能上一个台阶。</p><p>本机器人是一个基于计算机视觉的人机交互平台的雏形，我们的数据集可扩大到更多不同的物品，乃至声音，自然语言等。机器人能做出的反应指令可扩大到更复杂认知，机器模型结构也可以更为复杂精密。我们的项目验证了这样一个平台的可能性，这就是我们课题所解决的问题。</p><p>NVIDIA GPU Jetson TX1提供了在传统机器人系统中使用的CPU无法提供的人工智能计算能力，该小车除了视频模块外，还可以搭载语言识别和语义检测输入模块，声源定位技术，生机电模块等，有丰富的扩展空间。</p><p>由于该智能小车基于ROS平台开放性强，低耦合性，我们的智能小车可以运用于各类不同的应用场景。</p><p>首先，在家用场景中，我们的小车可以将训练图片集扩展到用户的不同手势和身体姿态，实现智能跟随功能与陪功能。同时，可以与SLAM室内定位相结合，在SLAM定位的过程中，根据定位过程中遇到的移动障碍物的不同情景作出反应，提高定位精确度。</p><p>在安防场景中，小车可以加入除了网络视频模块，加入人脸识别技术中的人脸遮挡检测，对于可疑人员进行跟踪报警，并将视频记录上传。</p><p>在地震救援场景中，该小车可通过高像素摄像头识别出被困人脸，并结合被困人的呼救声进行声源定位，声音与视频信号双重保障，使得救援小车能够更好地输送救灾物资。</p><p><strong>项目使用指南</strong></p><p>首先按电源键开启小车。</p><p>在小车行驶过程中，使用者可在摄像头前放置不同物品或物品的图片，小车即可做出不同反馈。同时，使用者也可以通过远程桌面上的按钮控制小车的前进，后退，停止，旋转。</p><p>1) 遇到小猫图片，向前直行两秒  Aasss</p><p>2) 捕捉牛图片，向后直行两秒</p><p>3) 捕捉自行车图片，原地向右旋转360度</p><p>4) 看到羊，原地向左旋转360度</p><p>5) 看到椅子，原地向右90度转弯并直行两秒</p><p>6) 看到汽车，原地向左90度转弯并直行两秒</p><p>注意：小车仅在出发地接受图片指令，动作行进过程中不接受新的图片指令输入。如需在小车行驶过程中控制小车，可在远程桌面的界面按钮停止。</p><p>小车自带的两个声纳模块，可帮助小车在行驶过程中避免障碍物。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;201705 交大黑客松（Hacker Marathon)纪要&lt;/p&gt;
    
    </summary>
    
      <category term="研究僧日常" scheme="kuberme.cn/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="Jetson TX1" scheme="kuberme.cn/tags/Jetson-TX1/"/>
    
      <category term="CUDA" scheme="kuberme.cn/tags/CUDA/"/>
    
      <category term="智能小车" scheme="kuberme.cn/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Run a cpp Example on Win10 Docker with VS Build Tools</title>
    <link href="kuberme.cn/Run-a-cpp-Example-on-Win10-Docker-with-VS-Build-Tools/"/>
    <id>kuberme.cn/Run-a-cpp-Example-on-Win10-Docker-with-VS-Build-Tools/</id>
    <published>2017-05-15T08:40:11.000Z</published>
    <updated>2020-04-15T03:23:32.828Z</updated>
    
    <content type="html"><![CDATA[<p>Sometimes when you need to use a cpp runtime environments on Windows system for your special applications, you can just install a Visuo Studio xxx to do it. But if you want to dilivery it to cloud environment, maybe you need make it into a Docker just like me. </p><a id="more"></a><!--toc--><h3 id="Install-Docker-into-Win10"><a href="#Install-Docker-into-Win10" class="headerlink" title="Install Docker into Win10"></a>Install Docker into Win10</h3><ol><li><p>Install <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci13aW5kb3dzL2luc3RhbGwv">Docker CE<i class="fa fa-external-link-alt"></i></span> in one computer with Windows 10 system, which its Virtualization must to be turn on firstly in your BIOS.</p></li><li><p>Note that, you need to log out once to complete installation when the installation succeeded.</p></li><li><p>After it, when you start Docker, it will check your computer setting of Hyper-V. </p><p><img src="http://blog.kuberfly.me/2017/05/15/Run-a-cpp-Example-on-Win10-Docker-with-VS-Build-Tools/windows_feature.png" alt="Windows Feature"><br>Hyper-v must be turn on status when you run Docker, which means your Virtual Box can not be used in the meantime. maybe there will have one computer restart here, don’t panic, this is the last restart if you only use Docker instead of virtual machines.</p></li><li><p>After Docker started, you can find a penguin log in your taskbar. here has some tips to help you test Docker or improve Docker.</p><ol><li><p>Switch Registry: </p><p>You can switch your registry to <span class="exturl" data-url="aHR0cHM6Ly9yZWdpc3RyeS5kb2NrZXItY24uY29tLw==">China Official Registry<i class="fa fa-external-link-alt"></i></span> by edit the Daemon which by right click your Docker to choose Setting. Or you can change registry to a private registry like your aliyun’s speeder address.<br><img src="http://images.5bug.wang//2018/03/201803016053_9660.png" alt="Switch Regostry"></p></li><li><p>Switch to Windows Container Mode: </p><p>In order to use windows images in Docker, you must change mode from Linux Container to Windows Container. after that, you can check it through <code>docker version</code> command.</p><p><img src="https://yqfile.alicdn.com/b7e02a92cc7689b498dc430e3a6b264c332c9c1f.png" alt="switch"></p></li><li><p>First example of windows container: execute <code>docker version</code> in your cmd.exe, then the client and server information for Docker will be shown. After that,  you can execute <code>docker run microsoft/sample-dotnet</code> in your cmd.exe or Windows PowerShell.exe (more popular and more convenient) . if there has a logo output, your installation would be correct.</p></li></ol></li></ol><h3 id="Load-a-Windows-Image-with-VS-Build-Tools"><a href="#Load-a-Windows-Image-with-VS-Build-Tools" class="headerlink" title="Load a Windows Image with VS Build Tools"></a>Load a Windows Image with VS Build Tools</h3><ol><li><p>Basic Commands: </p><p>After your Docker installation succeeded, you can always use it in your PowerShell through some usual commands to get some basic status like the bellowed.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#list running containers</span><br><span class="line">docker ps</span><br><span class="line">#list all containers(include running/exited/created)</span><br><span class="line">docker ps -a</span><br><span class="line">#list images</span><br><span class="line">docker images</span><br><span class="line">#check basic info of your Docker</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure></li><li><p><strong>Load Images</strong>: </p><p>So, if you want to run a container with cpp files in it, you need to have a windows image with VS build tools environment first. I already packed a ready image, this image is built by <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1YmVydGFsay9Eb2NrZXJJbWFnZS1XaW5zZXJ2ZXIvYmxvYi9tYXN0ZXIvRG9ja2VyZmlsZT8xNTU2NDUxMjk4MDAw">Dockerfile<i class="fa fa-external-link-alt"></i></span>, which is from a source image <code>microsoft/windowsservercore</code> with Visual Studio Build Tools in it. You just need to load my image into a new folder on your system through <strong><em><code>docker load -i \\cd-srv04\pxa\Projects\simulation\docker-images\winservercore-vstools.tar</code></em></strong>. </p><p>PS: if you want to what’s the difference of <code>windowsservercore</code> and <code>nanoserver</code>, please visit <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vdmlydHVhbGl6YXRpb24vd2luZG93c2NvbnRhaW5lcnMvZGVwbG95LWNvbnRhaW5lcnMvZGVwbG95LWNvbnRhaW5lcnMtb24tc2VydmVy">here<i class="fa fa-external-link-alt"></i></span>.</p><p>if you want to know how to build your own windows image, please visit <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9sYWJzL2Jsb2IvbWFzdGVyL3dpbmRvd3Mvd2luZG93cy1jb250YWluZXJzL1dpbmRvd3NDb250YWluZXJzLm1kPzE1NTY0NDYzMzIxNTM=">here<i class="fa fa-external-link-alt"></i></span>.</p><p>and if you want to know the how to build and save the image we are using, and the please see <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1YmVydGFsay9Eb2NrZXJJbWFnZS1XaW5zZXJ2ZXI=">here<i class="fa fa-external-link-alt"></i></span>. </p></li><li><p>Check Images:</p><p>Use <strong><code>docker images</code></strong> to check if this image already in your system when it load finished.</p><p><img src="http://blog.kuberfly.me/2017/05/15/Run-a-cpp-Example-on-Win10-Docker-with-VS-Build-Tools/check_images.png" alt="Check Images"></p></li></ol><h3 id="Start-a-Container-with-a-Interactive-Cmdlet"><a href="#Start-a-Container-with-a-Interactive-Cmdlet" class="headerlink" title="Start a Container with a Interactive Cmdlet"></a>Start a Container with a Interactive Cmdlet</h3><ol><li><p>After the image load successfully, you can run a container with this image, or you can build other images using this image.</p></li><li><p>Start a Container:</p><p>Use <strong><em><code>docker run -it -v $host-code-addr:$container-code-addr win-vs</code></em></strong> to start a container with a interactive cmdlet, just like the below picture. Then you can do everything you like in this container.</p><p><img src="http://blog.kuberfly.me/2017/05/15/Run-a-cpp-Example-on-Win10-Docker-with-VS-Build-Tools/start_container.png" alt="Start Container"></p></li><li><p>About the above command, just give you some tips for it:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$host-code-addr = c:/xxx/code   #code address in host computer, means container outer</span><br><span class="line">$container-code-addr = c:/code  #code address in container inner</span><br><span class="line"></span><br><span class="line">docker run -it -v $host-code-addr:$container-code-addr win-vs</span><br><span class="line"># -i,--Interactive: keep STDIN open</span><br><span class="line"># -t,--tty : allocate a pseudo-TTY</span><br><span class="line"># -v,--volume list: Bind mount a volume</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><strong>Compile and Run a Hello World</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd code</span><br><span class="line">#compile your files</span><br><span class="line">cl .\hello.cpp /EHsc</span><br><span class="line">#run your application</span><br><span class="line">.\hello</span><br></pre></td></tr></table></figure><p><img src="http://blog.kuberfly.me/2017/05/15/Run-a-cpp-Example-on-Win10-Docker-with-VS-Build-Tools/hello_world.png" alt="Run Hello-World"></p></li><li><p>Move your whole application of vc++ code to your shared volume on your host computer, and make it in your container. just have a try !</p></li><li><p>After test or debug on this pseudo cmdlet, you can use <code>exit</code> or <code>ctl+P+Q</code> to quit this window. Then you can use <code>docker start/restart -i $containerID</code>  to go back this container’s cmdlet.</p></li></ol><h3 id="QA-and-Issues"><a href="#QA-and-Issues" class="headerlink" title="QA and Issues"></a>QA and Issues</h3><p><strong>Have a fun and if you have any issues or problem, please don’t hesitate to contact me with <span class="exturl" data-url="bWFpbHRvOmt1YmVydHFpdUBob3RtYWlsLmNvbQ==">kubertqiu@hotmail.com<i class="fa fa-external-link-alt"></i></span></strong>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sometimes when you need to use a cpp runtime environments on Windows system for your special applications, you can just install a Visuo Studio xxx to do it. But if you want to dilivery it to cloud environment, maybe you need make it into a Docker just like me. &lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="kuberme.cn/categories/DevOps/"/>
    
    
      <category term="Docker" scheme="kuberme.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>八大排序算法  by C++ (转)</title>
    <link href="kuberme.cn/Top-8-Sorting-Algorithm(cpp)/"/>
    <id>kuberme.cn/Top-8-Sorting-Algorithm(cpp)/</id>
    <published>2017-04-28T07:20:55.000Z</published>
    <updated>2020-04-26T05:13:15.692Z</updated>
    
    <content type="html"><![CDATA[<p>八大排序算法  by C++ (转)</p><a id="more"></a><!--toc--><h4 id="八大排序算法-by-C-转"><a href="#八大排序算法-by-C-转" class="headerlink" title="八大排序算法  by C++ (转)"></a>八大排序算法  by C++ (转)</h4><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">​arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">​arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> tmp;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">​arr[j] = arr[i];</span><br><span class="line">​arr[i] = tmp;</span><br><span class="line">​i=j;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">else</span></span><br><span class="line">​<span class="keyword">break</span>;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void SelectSort(int arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">​int i,j,min, tmp;</span><br><span class="line">​for (i=0;i&lt;len-1;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​min = i;</span><br><span class="line">​for (j=i+1;j&lt;len;j++)</span><br><span class="line">​&#123;</span><br><span class="line">​if (arr[min] &gt; arr[j])</span><br><span class="line">​&#123;</span><br><span class="line">​min = j;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">​tmp = arr[min];</span><br><span class="line">​arr[min] = arr[i];</span><br><span class="line">​arr[i] = tmp;</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span>* temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((r-l+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">​<span class="keyword">int</span> i=l, j = mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">​<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">if</span> (arr[i] &lt;= arr[j])</span><br><span class="line">​&#123;</span><br><span class="line">​temp[k++] = arr[i];</span><br><span class="line">​i++;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">else</span></span><br><span class="line">​&#123;</span><br><span class="line">​temp[k++] = arr[j];</span><br><span class="line">​j++;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">​&#123;</span><br><span class="line">​temp[k++] = arr[i];</span><br><span class="line">​i++;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">​&#123;</span><br><span class="line">​temp[k++] = arr[j];</span><br><span class="line">​j++;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​arr[l+i] = temp[i];</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">if</span> (l &lt; r)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">​MergeSort(arr, l, mid);</span><br><span class="line">​MergeSort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">​MergeArray(arr, l, r, mid);</span><br><span class="line">​&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AdjustArr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> i=l,j=r,tmp=arr[l];</span><br><span class="line">​<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">while</span>(arr[j] &gt; tmp &amp;&amp; i&lt;j)</span><br><span class="line">​&#123;</span><br><span class="line">​j--;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">if</span> (i&lt;j)</span><br><span class="line">​&#123;</span><br><span class="line">​arr[i++] = arr[j];<span class="comment">// ++</span></span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">while</span>(arr[i] &lt; tmp &amp;&amp; i&lt;j)</span><br><span class="line">​&#123;</span><br><span class="line">​i++;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">if</span> (i&lt;j)</span><br><span class="line">​&#123;</span><br><span class="line">​arr[j--] = arr[i];</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">​arr[i] = tmp;</span><br><span class="line">​<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">if</span> (l &lt; r)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">int</span> k = AdjustArr(arr, l, r);</span><br><span class="line">​QuickSort(arr,l,k<span class="number">-1</span>);</span><br><span class="line">​QuickSort(arr,k+<span class="number">1</span>,r);</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> step = len / <span class="number">2</span>;</span><br><span class="line">​<span class="keyword">int</span> tmp;</span><br><span class="line">​<span class="keyword">for</span> (;step &gt; <span class="number">0</span>;step /= <span class="number">2</span>)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;step;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> j=i+step;j&lt;len;j+=step)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> k=j-step;k&gt;=<span class="number">0</span>;k-=step)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">if</span> (arr[j] &lt; arr[k])</span><br><span class="line">​&#123;</span><br><span class="line">​tmp = arr[j];</span><br><span class="line">​arr[j] = arr[k];</span><br><span class="line">​arr[k] = tmp;</span><br><span class="line">​j = k;<span class="comment">// attention</span></span><br><span class="line"></span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">else</span></span><br><span class="line">​<span class="keyword">break</span>;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapDown</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> i=first, j=<span class="number">2</span>*i+<span class="number">1</span>,tmp;</span><br><span class="line">​<span class="keyword">while</span>(j&lt;last)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">if</span> (arr[j] &lt; arr[j+<span class="number">1</span>])</span><br><span class="line">​&#123;</span><br><span class="line">​j++;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">​&#123;</span><br><span class="line">​tmp = arr[j];</span><br><span class="line">​arr[j] = arr[i];</span><br><span class="line">​arr[i] = tmp;</span><br><span class="line">​i = j;</span><br><span class="line">​j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">else</span></span><br><span class="line">​<span class="keyword">break</span>;</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> tmp;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> i = len/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">​&#123;</span><br><span class="line">​HeapDown(arr, i, len<span class="number">-1</span>);</span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">​&#123;</span><br><span class="line">​tmp = arr[<span class="number">0</span>];</span><br><span class="line">​arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">​arr[i] = tmp;</span><br><span class="line">​HeapDown(arr, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> nExp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> bucketArr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">​<span class="keyword">int</span> *outputs = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">​<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​bucketArr[(arr[i]/nExp)%<span class="number">10</span>]++;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">​&#123;</span><br><span class="line">​bucketArr[j] += bucketArr[j<span class="number">-1</span>];</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">// attention</span></span><br><span class="line">​&#123;</span><br><span class="line">​outputs[bucketArr[(arr[i]/nExp)%<span class="number">10</span>]<span class="number">-1</span>] = arr[i];</span><br><span class="line">​bucketArr[(arr[i]/nExp)%<span class="number">10</span>]--;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​arr[i] = outputs[i];</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="built_in">free</span>(outputs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> i, nMax = arr[<span class="number">0</span>], nExp;</span><br><span class="line">​<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="keyword">if</span> (nMax &lt; arr[i])</span><br><span class="line">​&#123;</span><br><span class="line">​nMax = arr[i];</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">for</span> (nExp = <span class="number">1</span>; nMax/nExp&gt;<span class="number">0</span>; nExp *= <span class="number">10</span>)</span><br><span class="line">​&#123;</span><br><span class="line">​BucketSort(arr, len, nExp);</span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Just-Test-It"><a href="#Just-Test-It" class="headerlink" title="Just Test It"></a>Just Test It</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> arr[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">55</span>,<span class="number">0</span>&#125;;</span><br><span class="line">​<span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">​<span class="comment">//BubbleSort(arr, len);</span></span><br><span class="line">​<span class="comment">//InsertSort(arr, len);</span></span><br><span class="line">​<span class="comment">//SelectSort(arr, len);</span></span><br><span class="line">​<span class="comment">//MergeSort(arr, 0, len-1);</span></span><br><span class="line">​<span class="comment">//QuickSort(arr, 0, len-1);</span></span><br><span class="line">​<span class="comment">//ShellSort(arr, len);</span></span><br><span class="line">​<span class="comment">//HeapSort(arr, len);</span></span><br><span class="line">​RadixSort(arr, len);</span><br><span class="line">​<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">​&#123;</span><br><span class="line">​<span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">​system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;八大排序算法  by C++ (转)&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="归并排序" scheme="kuberme.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="kuberme.cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="kuberme.cn/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="kuberme.cn/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="kuberme.cn/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
      <category term="桶排序" scheme="kuberme.cn/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="kuberme.cn/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="kuberme.cn/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="kuberme.cn/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库篇笔记-1-数据库基础概念</title>
    <link href="kuberme.cn/SQL-Study-Note/"/>
    <id>kuberme.cn/SQL-Study-Note/</id>
    <published>2017-04-25T02:40:55.000Z</published>
    <updated>2020-04-26T02:18:44.788Z</updated>
    
    <content type="html"><![CDATA[<p>复习数据库笔记之数据库基础概念</p><a id="more"></a><!--toc--><h4 id="数据库概念集合"><a href="#数据库概念集合" class="headerlink" title="数据库概念集合:"></a>数据库概念集合:</h4><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><ul><li><p><strong>共享锁</strong></p><p>又称读锁（S锁），若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，但不能加X锁，直到T释放A上的S锁。</p></li><li><p><strong>排它锁</strong></p><p>又称写锁（X锁），若事务T对数据对象加上X锁，则只允许T<strong>读取和修改</strong>A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。</p></li><li><p><strong>死锁</strong></p><p>进程死锁，是个计算机技术名词。它是操作系统或软件运行的一种状态：在多任务系统下，当一个或多个进程等待系统资源，而资源又被进程本身或其它进程占用时，就形成了 死锁 。</p><p>数据库中的死锁，两个或多个事务都已经封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。</p><p>数据库中为了实现并发控制，采取了封锁技术，但是封锁技术又会带来活锁和死锁的问题，所以死锁不是数据库事务并发带来的问题，而是解决事务并发带来的问题。</p></li></ul><h5 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h5><ul><li>修改表结构包括：增加字段、删除字段、增加约束、删除约束、修改缺省值、修改字段数据类型、重命名字段、重命名表。所有的这些动作都是用alter table命令执行的。</li></ul><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性或独立性）和Durability（持久性）的英文缩写。</p><p>​     1. <strong>原子性</strong>： 指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</p><p>​    2. <strong>一致性</strong>： 指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p><p>​    3. <strong>隔离性 （或独立性）</strong>：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p>​    4. <strong>持久性</strong>： 指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p><ul><li><p><strong>脏读</strong>：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。<br>例如：<br>张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。<br>与此同时，<br>事务B正在读取张三的工资，读取到张三的工资为8000。<br>随后，<br>事务A发生异常，而回滚了事务。张三的工资又回滚为5000。<br>最后，<br>事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。</p></li><li><p><strong>不可重复读</strong>：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。<br>例如：<br>在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。<br>与此同时，<br>事务B把张三的工资改为8000，并提交了事务。<br>随后，<br>在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p></li><li><p><strong>幻读</strong>：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。<br>例如：<br>目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。<br>此时，<br>事务B插入一条工资也为5000的记录。<br>这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p></li><li><p><strong>未提交读</strong>： 一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而 且能看到其他事务没有提交的对已有记录的更新。</p></li><li><p><strong>已提交读</strong>： 一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新。</p></li><li><p><strong>可重复读</strong>： 一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他其他事务对已有记录的更新。</p></li><li><p><strong>串行化</strong>： 一个事务在执行过程中完全看不到其他事务对数据库所做的更新。（事务执行的时候不允许别的事务并发执行。事务串行化执行，事务只能一个接着一个地执行，而不能并发执行）</p></li></ul><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><ol><li><p><strong>普通索引</strong></p><p>普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREcolumn=）或排序条件（ORDERBYcolumn）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。唯一索引</p></li><li><p><strong>唯一索引</strong><br>普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。</p><p>如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</p></li><li><p><strong>主索引</strong></p><p>在前面已经反复多次强调过：必须为主键字段创建一个索引，这个索引就是所谓的“主索引”。主索引与唯一索引的唯一区别是：前者在定义时使用的关键字是PRIMARY而不是UNIQUE。主键是唯一标示的。</p></li></ol><ul><li><strong>b-tree索引</strong><br>Oracle数据库中最常见的索引类型是b-tree索引，也就是B-树索引，以其同名的计算科学结构命名。CREATE<br>INDEX语句时，默认就是在创建b-tree索引。没有特别规定可用于任何情况。</li><li><strong>位图索引</strong>(bitmap index)<br>位图索引特定于该列只有几个枚举值的情况，比如性别字段，标示字段比如只有0和1的情况。</li><li><strong>基于函数的索引</strong><br>比如经常对某个字段做查询的时候是带函数操作的，那么此时建一个函数索引就有价值了。</li><li><strong>分区索引和全局索引</strong><br>这2个是用于分区表的时候。前者是分区内索引，后者是全表索引</li><li><strong>反向索引</strong>（REVERSE）<br>这个索引不常见，但是特定情况特别有效，比如一个varchar(5)位字段(员工编号)含值（10001,10002,10033,10005,10016..）。这种情况默认索引分布过于密集，不能利用好服务器的并行，但是反向之后10001,20001,33001,50001,61001就有了一个很好的分布，能高效的利用好并行运算。</li><li><strong>HASH索引</strong><br>HASH索引可能是访问数据库中数据的最快方法，但它也有自身的缺点。集群键上不同值的数目必须在创建HASH集群之前就要知道。需要在创建HASH集群的时候指定这个值。使用HASH索引必须要使用HASH集群。</li></ul><h5 id="索引优化注意事项"><a href="#索引优化注意事项" class="headerlink" title="索引优化注意事项"></a>索引优化注意事项</h5><ol><li>表的主键、外键必须有索引；</li><li>数据量超过300的表应该有索引；</li><li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：</li><li>正确选择复合索引中的主列字段，一般是选择性较好的字段；</li><li>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如</li><li>则可以建立复合索引；否则考虑单字段索引；</li><li>如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；</li><li>如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；</li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；</li><li>频繁进行数据操作的表，不要建立太多的索引；</li><li>删除无用的索引，避免对执行计划造成负面影响；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习数据库笔记之数据库基础概念&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="kuberme.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库索引" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
      <category term="数据库事务" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="数据库锁" scheme="kuberme.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Nvidia Jetson TK1 board set up and get started</title>
    <link href="kuberme.cn/Nvidia-Jetson-TK1-board-set-up-and-get-started/"/>
    <id>kuberme.cn/Nvidia-Jetson-TK1-board-set-up-and-get-started/</id>
    <published>2017-03-26T10:47:20.000Z</published>
    <updated>2020-04-26T02:13:46.089Z</updated>
    
    <content type="html"><![CDATA[<p>老师给了一块NVIDIA Terga K1的开发板，让我玩玩看。</p><a id="more"></a><!--toc--><p>给我的时候里面是ubuntu14.04的系统，但明显兼容性太差，乱码和闪退问题太多。所以我决定自己刷个原生系统。因为要跑cuda程序，所以安装cuda6.5（cuda7.0目前还不支持TK1板子）<br>整个的步骤一共三步：1.下载 2.设置 3.安装cuda6.5</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>1) 在Linux下，到L4T的页面，找到Jetson TK1和sample file system这两个下载：<br>下载链接在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9lbWJlZGRlZC9saW51eC10ZWdyYQ==">这里<i class="fa fa-external-link-alt"></i></span>，界面如下：<br><img src="http://blog.kuberfly.me/2017/03/26/Nvidia-Jetson-TK1-board-set-up-and-get-started/jetson_package.png" alt="Jetson Downloading"><br>目前最新的版本是R21.4，以这个版本为例，下载下来的是两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tegra124_Linux_R21.4.0_armhf.tbz2</span><br><span class="line">Tegra_Linux_Sample-Root-Filesystem_R21.4.0_armhf.tbz2</span><br></pre></td></tr></table></figure><p>我把这两个文件放在Downloads文件夹下，先解压驱动包<br><code>$sudo tar --numeric-owner -jxpf Tegra124_Linux_R21.4.0_armhf.tbz2</code><br>在解压刷机需要的文件的时候，需要用<code>--numeric-owner</code>选项，否则就会出现权限问题。作为Linux小白，保险起见，解压还是加上了这个选项.<br>等待解压结束，Downloads文件下会出现一个<code>Linux_for_Tegra</code>文件夹。这个文件夹下有一个<code>rootfs</code>的文件夹，这里就是要放L4T的地方了，所以先进入<code>rootfs</code>文件夹：<br><code>$cd Linux_for_Tegra/rootfs</code><br>然后在该文件下解压基于Ubuntu的<code>L4T Sample Image</code>：<br><code>$sudo tar --numeric-owner -jxpf ../../Tegra_Linux_Sample-Root-Filesystem_R21.4.0_armhf.tbz2</code><br>然后返回上层文件夹：<br><code>$cd ..</code><br>执行安装脚本，会生成真正的system image。<br><code>$sudo ./apply_binaries.sh</code></p><h4 id="开始刷机"><a href="#开始刷机" class="headerlink" title="开始刷机"></a>开始刷机</h4><p>刷机之前，仔细阅读<code>Jeston_TK1_QuickStartGuide</code>，在网站上能找到。 先把网线、HDMI线、外接usb hub都接好，在接好micro usb线（一头在TK1上，一头在host上，这里使用一台ubuntu14.04的host），最后通电源。<br>刷机时，先按住板子最边缘的<code>force recovery</code>按钮不松开，然后按一下reset，板子会重启进入<code>recovery mode</code>（听见风扇声音变化），这个时候你会发现系统当前目录下（Downloads目录下）新mount上了一个16G的eMMC设备。（可看见flash.sh这些文件）<br>然后执行刷机命令：<br><code>$sudo ./flash.sh -S 8GiB jetson-tk1 mmcblk0p1</code><br><code>mmcblk0p1</code>就是板子内部存储对应的设备名。<br>刷机成功后板子重启，就能进入Ubuntu界面了，原本还需要执行网络的一些配置，但我做的时候是直接可以上网了的，这里只列出来，但不用操作）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sudo dhclient eth0</span><br><span class="line">$ifconfig</span><br><span class="line">$sudo apt-get update</span><br><span class="line">$sudo apt-get install ubuntu-desktop</span><br></pre></td></tr></table></figure><p>手动刷机成功。</p><p>自动刷机<br>事实上Jetson TK1的官网也提供了傻瓜刷机包JetPack，只要到Jetpack的网页下载<code>JetPackTK1-1.1-cuda6.5-linux-x64.run</code>到进行刷机操作的Linux里，然后执行<br><code>$chmod +x JetPackTK1-1.1-cuda6.5-linux-x64.run</code><br>然后双击，就会弹出图形界面，按照界面一步步来就能搞定从驱动到L4T到OpenCV和CUDA的所有相关包，不过鉴于前面所说的可能出现的权限问题，我还是放弃了这个套路。</p><h4 id="安装cuda6-5（-run方式）"><a href="#安装cuda6-5（-run方式）" class="headerlink" title="安装cuda6.5（.run方式）"></a>安装cuda6.5（.run方式）</h4><p>在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9lbWJlZGRlZC9saW51eC10ZWdyYQ==">这个<i class="fa fa-external-link-alt"></i></span>页面下找到CUDA和OpenCV的deb包下载之。<br>1.Perform the pre-installation actions. （忽略了，无非是些检查）<br>2. Install repository meta-data<br><code>$ sudo dpkg -i cuda-repo-l4t-r21.3-6-5-prod_6.5-42_armhf</code> （可以下载下来拷过去）<br>3. Update the Apt repository cache<br><code>$ sudo apt-get update</code><br>4. Install CUDA Toolkit<br><code>$ sudo apt-get install cuda-toolkit-6-5</code> （是在线安装的，结果导致那天晚上回去太晚被媳妇儿批）<br>5. Add the user to the video group（因为要访问gpu，必须把用户添加到video组下）<br><code>$ sudo usermod -a -G video</code></p><p>至此就已经安装好了，<code>cuda-toolkit</code>和<code>cuda-samples</code>都好了，因为<code>armhf</code>那个包里面已经包含两者）<br>下面进入usr/local/下，可以看到cuda的真身了。<br><code>$cd usr/local/cuda/</code><br>看到Samples,进去可以看到各种例子已经在了。<br>下面因为这个Samples权限是只读，所以复制他出来,执行编译好的脚本就可以复制。<br><code>$./cuda-install-samples-6.5.sh /home/ubuntu/</code><br>回到<code>home/</code>目录下就可以看到有一个<code>NVIDIA-6.5_Samples</code>的文件了。<br>使用<code>make</code>编译，整体编译,或者分开编译。（这里是原生编译即使用板子上arm的cpu编译，速度相对慢一点）<br>然后进入编译好的文件目录下<br><code>$cd /home/ubuntu/NVIDIA-6.5_Samples/bin/armvl7/linux/release/gnueabinf</code><br>来用<code>./xxx</code>执行任意编译好的文件<br>这里要解个毒，执行<code>./smokeparticles</code>时候，理论上在65536的什么的情况下，可以达到30多帧的一个分辨率，应该具有很强的推动能力，但是在我的板子上跑起来，完全不是那么回事儿，动画特别慢。<br>至此，全部我对TK1的初期目标达成。</p><h4 id="使用cuda"><a href="#使用cuda" class="headerlink" title="使用cuda"></a>使用cuda</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$mkdir test</span><br><span class="line">$sudo vim test1.cu</span><br><span class="line">//粘贴代码，保存退出</span><br><span class="line">$nvcc test1.cu -o test1</span><br><span class="line">$./test1</span><br><span class="line">//其他均可以此类推。</span><br></pre></td></tr></table></figure><p>PS: vim编辑器确实好用，下次可试emac编辑器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老师给了一块NVIDIA Terga K1的开发板，让我玩玩看。&lt;/p&gt;
    
    </summary>
    
      <category term="研究僧日常" scheme="kuberme.cn/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="CUDA" scheme="kuberme.cn/tags/CUDA/"/>
    
      <category term="Jetson TK1" scheme="kuberme.cn/tags/Jetson-TK1/"/>
    
  </entry>
  
  <entry>
    <title>Informal Discussion on Inferno</title>
    <link href="kuberme.cn/Informal-Discussion-on-Inferno/"/>
    <id>kuberme.cn/Informal-Discussion-on-Inferno/</id>
    <published>2017-03-18T04:43:59.000Z</published>
    <updated>2020-04-15T03:23:32.828Z</updated>
    
    <content type="html"><![CDATA[<p>研究生操作系统课程的作业–每人调研分享一个操作系统</p><a id="more"></a><!--toc--><h3 id="漫谈Inferno"><a href="#漫谈Inferno" class="headerlink" title="漫谈Inferno"></a><strong>漫谈Inferno</strong></h3><h4 id="Inferno-History"><a href="#Inferno-History" class="headerlink" title="Inferno History"></a><strong>Inferno History</strong></h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPUlFRUVfSW50ZXJuZXRfQ29tcHV0aW5nJmFjdGlvbj1lZGl0JnJlZGxpbms9MQ==">IEEE Internet Computing<i class="fa fa-external-link-alt"></i></span>在1997年3-4月的刊物中有Inferno网络软件的广告。该广告宣称可利用多种设备在包含互联网、电信网络，以及局域网等之”任何网络”上进行通讯。图中甚至摆放了<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUGxheVN0YXRpb24=">PlayStation<i class="fa fa-external-link-alt"></i></span>之类的照片，如果电玩可以跟电脑沟通、手机可以访问电子邮件、电视可以访问语音邮件。</li><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5pyX6KiK56eR5oqA">朗讯科技<i class="fa fa-external-link-alt"></i></span>至少有两个内部项目有采用Inferno：Lucent VPN Firewall Brick以及Lucent Pathstar phone switch。这也打开了贩卖Inferno源代码授权的尝试，不过反应并不热烈。朗讯科技没特别做营销又忽略了Inferno与互联网的重要关连，而<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSmF2YQ==">Java语言<i class="fa fa-external-link-alt"></i></span>跟Inferno目标市场相似、采用类似的技术、可以在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv57ay6aCB54CP6Ka95Zmo">网页浏览器<i class="fa fa-external-link-alt"></i></span>中运行，也同时满足了当时对于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvT09Q">面向对象语言<i class="fa fa-external-link-alt"></i></span>的流行。当<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5piH6Zm96Zu76IWm">SUN<i class="fa fa-external-link-alt"></i></span>大力营销自家的Java时，朗讯科技自太阳微系统获取Java的授权，宣称所有Inferno的设备皆能运行Java。Java比特码与Dis比特码的转译器就是为了达成这个功能所产生的。然而Inferno还是卖不出去。</li><li>Inferno商业部门过了三年就关闭且被卖给<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPVZpdGFfTnVvdmFfSG9sZGluZ3MmYWN0aW9uPWVkaXQmcmVkbGluaz0x">Vitanuova<i class="fa fa-external-link-alt"></i></span>在1999年。Vitanuova持有相关的权利后，便继续研发并对整个系统采用商业化授权的方式，随后提供免费下载以及对核心以及虚拟机以外的整个系统采用非<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR1BM">GPL<i class="fa fa-external-link-alt"></i></span>兼容授权的方式。Vitanuova将软件继续移植到新的硬件以及专注在分散式应用软件上，最终将源代码采用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR1BM">GPLv2<i class="fa fa-external-link-alt"></i></span>授权发布，而Inferno操作系统现今也变成是一个<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv6ZaL5pS+5Y6f5aeL56K8">开放源代码<i class="fa fa-external-link-alt"></i></span>的项目。</li></ul><h4 id="Licence-Terms"><a href="#Licence-Terms" class="headerlink" title="Licence Terms"></a><strong>Licence Terms</strong></h4><p>这里稍微提一句这个授权的问题，Inferno第四版于2004年以<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv6Ieq55Sx6Luf6auU">自由软件<i class="fa fa-external-link-alt"></i></span>的授权发布。具体来说，Inferno采用了<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv5aSa6Kix5Y+v">双授权<i class="fa fa-external-link-alt"></i></span>的方式采用了两种授权供用户选择。用户可选择在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPeiHqueUsei7n+mrlOaOiOasiiZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=">自由软件授权<i class="fa fa-external-link-alt"></i></span>或传统商业化授权的情况下获取Inferno。根据自由软件授权的规范，系统中各个部分可以采用不同的授权方式，这些授权方式包括<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR1BM">GPL<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTEdQTA==">LGPL<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2U=">MIT License<i class="fa fa-external-link-alt"></i></span>，以及<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPUx1Y2VudF9QdWJsaWNfTGljZW5zZSZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=">Lucent Public License<i class="fa fa-external-link-alt"></i></span>。这种就是根据不同的协议，在你做出修改后想要再传播时，需不需要公开修改的那部分代码。如果你不想公开任何一部分干脆使用商业版本，一开始付一点费用就可以。后来Vita Nuova让Inferno可以在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR1BM">GPLv2<i class="fa fa-external-link-alt"></i></span>的授权下获取除了字体（采用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPUJpZ2Vsb3dfYW5kX0hvbG1lcyZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=">Bigelow and Holmes<i class="fa fa-external-link-alt"></i></span>授权）以外的整个系统。现在总共有三种授权方式可供选择。</p><p>这里面有一个<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPUx1Y2VudF9QdWJsaWNfTGljZW5zZSZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=">Lucent Public License<i class="fa fa-external-link-alt"></i></span>，顾名思义就是朗讯自己搞的一个协议，有1和1.02两版。Plan 9第四版用的就是LPL1.02版，这个协议虽然被FSF和OSI都接受，但和GPL并不相容，因为其中竟然说被老美的某州法和知识产权法所统治。</p><h4 id="Inferno’s-Features"><a href="#Inferno’s-Features" class="headerlink" title="Inferno’s Features"></a>Inferno’s Features</h4><h5 id="Cross-Platform-Portability"><a href="#Cross-Platform-Portability" class="headerlink" title="Cross-Platform Portability"></a><strong>Cross-Platform Portability</strong></h5><p>Inferno可以直接在原生硬件中运行，也能在其他平台以应用程序的方式提供虚拟操作系统。应用程序无须经过修改或重编译即可在所有的Inferno平台开发并运行, 大多数流行的操作系统和处理器架构都支持：详细请看课堂展示<a href>PPT</a>图。</p><h5 id="Limbo"><a href="#Limbo" class="headerlink" title="Limbo"></a><strong>Limbo</strong></h5><ul><li><p>Easy to Learn – 它的语法和C很相似，设计的很容易读和理解。</p></li><li><p>Absolutely Portable – 绝对便携的。源代码被编译成结构独立的小部分，能够很好的完全的跑在所有Inferno平台上。</p></li><li><p>Advanced Concurrency – 高并行性</p></li><li><p>Dynamic Modules – 动态的模块。除非在运行和被需要时候，载入的模块绝不会复制到内存里</p></li><li><p>Safe – 编译一关，运行时字符类型检查一关，运行时数组溢出检查又一关</p></li><li><p>Automatic Garbage Collection – 自动释放不用的内存</p></li></ul><h5 id="Principles"><a href="#Principles" class="headerlink" title="Principles"></a>Principles</h5><p><strong>Inferno is a distributed system based on the application of three basic principles.</strong></p><ul><li>Resources as files：把所有的资源都列在层次结构式文件系统中以文件表示。</li><li>Namespaces：从应用程序的观点来看，网络是种单一且清楚的命名空间，能展现层次结构式文件系统，也能代表近端或远程实体分离的资源。</li><li>Standard communication protocol：采用名为Styx的标准协议，用来访问近端或远程的所有资源。</li></ul><p>分开介绍三条原则：</p><ol><li><strong>Resources as files</strong><br>所有资源，无论在本地还是远程的，都被看做用层次化文件系统来表示的一个动态文件集。无论是存储设备，进程，服务，网络和网络连接，全都用文件来表示。一个应用程序可以访问每个资源，通过标准文件操作来进行。</li></ol><p>用文件作为中心概念的好处有：</p><ul><li>访问文件的接口基本由定义好的操作集组成，简单且易懂。例如open/read/write</li><li>文件系统减少了接口的代码量，使系统小巧灵活移植性好。</li><li>命名习惯规整且易懂。</li><li>访问权限和访问许可变得简单，还可以确保多级安全。</li></ul><p>每个请求和每个用户发出的访问请求时间点不同，返回的文件名可能都不同。</p><ol start="2"><li><strong>Namespaces：</strong><br>这第二个关键的原则就是可计算的命名空间，是一个应用程序建立独特的私有的视图来调用资源和服务时需要访问的东西。每一个资源集被描绘成文件层级，且用标准文件操作可以访问。各种不同的资源和服务被一个进程使用，都是要连接到某一个单个的root层级的文件名，这叫做命名空间。在一个个人的命名空间里，这些可访问的资源可以被定位到一个单个的客户或者多台服务器上通过网络。</li></ol><p>命名空间一个最大的优点就是应用程序可以完全的显然的使用资源。一旦某个资源被挂载到你的应用程序的命名空间下，你就可以使用它但不需要知道这个资源是在本地还是远程的。</p><p>举个例子，A机器想要使用B机器的CPU，只需要将B机器的CPU挂载到A机器的CPU的文件中，就能完成这个需求，但在上层来看完全是透明的，像在本地操作一样。当然两个机器之间来进行文件挂载表示的是有一个协议叫9P。最早只是在Plan 9中用到，后来派生的一个简单版叫styx。但现在的styx和9P2000基本是一模一样的。只是有的时候还改不过口叫styx。</p><p>Namespace Example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">This example describes a home network that consists of the following devices:</span><br><span class="line"></span><br><span class="line">t Windows PC t Digital Camera t Video Recorder t PDA (Compaq iPAQ, for example)</span><br><span class="line"></span><br><span class="line">The physical connection between the devices may be as follows:</span><br><span class="line"></span><br><span class="line">t Wireless 802.11b network connecting （无线连接）</span><br><span class="line"></span><br><span class="line">the iPAQ and the Windows PC</span><br><span class="line"></span><br><span class="line">t Ethernet network connecting the PC to the Video Recorder（以太网连接）</span><br><span class="line"></span><br><span class="line">t USB connection from the PC to the Digital Camera（usb连接）</span><br><span class="line"></span><br><span class="line">Step One - mount the different name spaces（挂载不同的命名空间到/n/remote下）</span><br><span class="line"></span><br><span class="line">Step Two - bind the namespaces together（bind所有命名空间到/homenetwork下）</span><br><span class="line"></span><br><span class="line">Step Three - run the application from the PC（在PC端跑应用程序）</span><br><span class="line"></span><br><span class="line">Step four - run the application from the IPAQ（在ipad端跑应用程序）</span><br><span class="line"></span><br><span class="line">Step 5 - run on the iPAQ store on PC</span><br></pre></td></tr></table></figure><p><img src="http://note.youdao.com/yws/res/4297/69A6530F06AB4B29939050ABA9F342FC" alt="img"></p><ol start="3"><li><strong>Standard protocol to access resources：</strong><br>Inferno使用单个的协议，由内核和应用程序来实现，为了表示或访问资源的。因为所有的资源包括网络网络连接都被看做文件，自然需要一个协议来通信和对于资源提供访问。这个协议就是就是styx或者9P了。这个方法通过使用已有的技术来连接远程的文件系统即建立起一个分布式系统。使用一个标准的通信协议还可以使得更集中注意在安全上。Inferno提供几个机制在安全通信上：</li></ol><ul><li>基于用户身份验证的授权</li><li>消息加密</li></ul><p>因为这是底层的一部分，对于所有的应用程序是透明的。</p><p>那么styx到底是什么呢？根据官方文档的其中一句话：</p><p>The Styx protocol is the specification of the messages that are exchanged.（styx是用来交换的信息的一个规范）大概是在OSI七层的第5层会话层。</p><p>At one level, Styx consists of messages of 13 types for（styx包括13个类型的消息，基本分为）</p><ul><li>Starting communication (attaching to a file system);（启动，连接上文件系统）</li><li>Navigating the file system (that is, specifying and gaining a handle for a named file);（导航指引你找到你需要的那个文件）</li><li>Reading and writing a file; and（读，写）</li><li>Performing file status inquiries and changes（显示文件的状态）</li></ul><p>Table Summary of Styx messages<br><img src="http://note.youdao.com/yws/res/4297/8E4A3F614B3A4627A77C64E6340040A0" alt="img"><br>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;/usr/rob/.profile&quot;, O_READ);</span><br><span class="line">——具体执行起来就是初始化</span><br><span class="line">——发送attach消息——</span><br><span class="line">返回FID即所寻文件系统的root目录</span><br><span class="line">——然后执行open消息</span><br><span class="line">——先复制一个FID</span><br><span class="line">——用新的FID通过walk消息导航找到所需文件</span><br><span class="line">——然后检查用户有没有读写权限</span><br><span class="line">——然后进行读和写</span><br><span class="line">——然后close释放FID</span><br><span class="line">__结束tcp/ip协议。</span><br></pre></td></tr></table></figure><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p><strong>Styx, as a file system protocol, is merely a component in a more encompassing approach to system design: the presentation of resources as files.(styx作为一个文件系统协议，只是系统设计大的这盘棋中一部分，但是很重要的一部分，即一起皆是文件。尽管unix最先提出的这个思想，linux也有继承，但styx确实更为彻底的，极具革新性的)</strong></p><p>举几个例子来看一下：</p><ul><li><strong>Example 1:debugging</strong><br>我们都知道/proc是unix里动态的控制获取内核信息包括进程等一些来用的。看这个例子，假设1、2就是系统正在运行的一些进程ID。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/proc/</span><br><span class="line"></span><br><span class="line">    1/</span><br><span class="line">        status</span><br><span class="line">        ctl</span><br><span class="line">        fd</span><br><span class="line">        text</span><br><span class="line">        mem</span><br><span class="line">        ...</span><br><span class="line">    2/</span><br><span class="line">        status</span><br><span class="line">        ctl</span><br><span class="line">        ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里的status显示的是进程状态的信息。Ctl显示的是一些控制的信息比如pausing暂停，restarting重启，killing关闭等；fd是一个整数，在文件open时产生。表示该文件在进程中打开；text代表程序源码；mem代表数据。</p><p>这里就是说前面提到过的类似的，当你想用远程的一台机器来调试你机器上的程序，只需要将本地的/proc文件方便的挂载到远程的机器上来调试。机器与机器是相互独立的，即使两台机器CPU架构都不相同。所以大多数与状态和控制相关的与机器无关的程序，是极其便携的。</p><ul><li><strong>Example 2：Networking</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/net/</span><br><span class="line">    dns/</span><br><span class="line">    tcp/</span><br><span class="line">        clone</span><br><span class="line">        stats</span><br><span class="line">        0/</span><br><span class="line">            ctl</span><br><span class="line">            status</span><br><span class="line">            data</span><br><span class="line">            listen</span><br><span class="line">        1/</span><br><span class="line">            ...     </span><br><span class="line">        ...</span><br><span class="line">    ether0/</span><br><span class="line">        0/</span><br><span class="line">            ctl</span><br><span class="line">            status</span><br><span class="line">            ...</span><br><span class="line">        1/</span><br><span class="line">            ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><p>假设一个应用程序想建立一个TCP/IP的连接到百度，第一步肯定是先由DNS服务器解析域名，返回一个IP地址，然后访问这个IP地址的网关，向这个服务器发送请求访问页面。</p><p>而styx则是，直接往/dev/dns/里写百度的域名，然后再读取同一个文件，就会返回一串IP地址了。IP地址收到后，进入/net/tcp/clone可以看到给出的一个同级的目录比如/net/tcp/0, 0是什么呢，正式一个新的独特的TCP/IP通道。而、net/tcp/0/ctl里则会存放控制信息，比如connect 202.108.22.5, 然后读写/net/tcp/0/data连接即为建立。</p><p>这里面很多是在服务器上完成的，都不一定是在本地的，但在用户看来，跟本地是一样的。这也是前面说过的命名空间的特点。</p><p>这里将接口间的通信从二进制信息变成了可读的字符串信息，所以再次验证了它是完全不依赖于CPU架构或者具体语言的。</p><p><strong>某种程度上讲，Inferno/Plan9这个分布式操作系统，它能把网络上一切的资源当作文件来进行使用，这其实就是云的概念了。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>那么到底为什么inferno或者说Plan 9没有火，而linux火了呢。总结一下就是，你想在大哥的基础上做改进特别好，但是你要是自立门户，几乎不跟大哥来往，那你一定活得不好。说到这里不是说Plan 9 或者inferno完全死了，他现在还是在vitanuova公司下运营，提供免费下载也卖商业版本。也不得不承认，他还是带来很多影响的。早期的freeBSD派和现在linux都从中有借鉴的地方。</p><p>那么Plan 9/inferno到底留下了什么呢？</p><p>我总结3点就是</p><ul><li>Change daily</li><li>Remain original</li><li>Adopted by others</li></ul><p>作为ken thomsen 的生平第三大作品，虽然没有成功，但从此留下功与过，回响在历史长河中。</p><p>PS: 在研究生第一学期操作系统课唯一一点留下来值得我思考的是：<br>网络的目的：构造分布式的计算环境。则需要同步和互斥。<br>软件的同步和互斥：信道语义（接收和发送）<br>更重要的硬件的同步和互斥：原子操作（测试指令xx）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;研究生操作系统课程的作业–每人调研分享一个操作系统&lt;/p&gt;
    
    </summary>
    
      <category term="研究僧日常" scheme="kuberme.cn/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E6%97%A5%E5%B8%B8/"/>
    
      <category term="操作系统" scheme="kuberme.cn/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E6%97%A5%E5%B8%B8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="kuberme.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>只如初见</title>
    <link href="kuberme.cn/first-blog/"/>
    <id>kuberme.cn/first-blog/</id>
    <published>2017-02-08T05:14:00.000Z</published>
    <updated>2020-04-15T03:23:32.832Z</updated>
    
    <content type="html"><![CDATA[<p>人生若只如初见，等闲秋风悲画扇。</p><a id="more"></a><p>第一篇博客，在你生日这天，献于你 LJN。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生若只如初见，等闲秋风悲画扇。&lt;/p&gt;
    
    </summary>
    
      <category term="KuberTalk" scheme="kuberme.cn/categories/KuberTalk/"/>
    
    
      <category term="随笔" scheme="kuberme.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
